"""
GLOBAL INTELLIGENCE SECURITY COMMAND CENTER - MALWARE CAPTURE AND ANALYSIS
Enterprise-grade malware capture, unpacking, decryption, and code display

This module implements:
- Capture of complete malware packages from URLs
- Safe unpacking of packed executables (UPX, MPRESS, ASPack, etc.)
- Decryption of obfuscated/encrypted code
- Complete code display with syntax highlighting
- Sandbox isolation for safe analysis

100% OPENSOURCE - NO EXTERNAL API DEPENDENCIES
Uses local analysis tools only

Classification: TOP SECRET // NSOC // TIER-5
"""

import os
import re
import json
import struct
import hashlib
import logging
import sqlite3
import tempfile
import subprocess
import threading
import base64
import zlib
import binascii
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime
from dataclasses import dataclass, field, asdict
from enum import Enum
import urllib.request
import urllib.error
import ssl

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class PackerType(str, Enum):
    UPX = "UPX"
    MPRESS = "MPRESS"
    ASPACK = "ASPack"
    PECOMPACT = "PECompact"
    THEMIDA = "Themida"
    VMPROTECT = "VMProtect"
    PETITE = "Petite"
    FSG = "FSG"
    NSPACK = "NSPack"
    UNKNOWN = "Unknown"


class ObfuscationType(str, Enum):
    XOR = "XOR"
    BASE64 = "Base64"
    ROT13 = "ROT13"
    AES = "AES"
    RC4 = "RC4"
    CUSTOM = "Custom"
    NONE = "None"


class MalwareCategory(str, Enum):
    RANSOMWARE = "Ransomware"
    RAT = "Remote Access Trojan"
    TROJAN = "Trojan"
    WORM = "Worm"
    VIRUS = "Virus"
    ROOTKIT = "Rootkit"
    BACKDOOR = "Backdoor"
    CRYPTOMINER = "Cryptominer"
    BOTNET = "Botnet"
    SPYWARE = "Spyware"
    ADWARE = "Adware"
    UNKNOWN = "Unknown"


@dataclass
class CapturedMalware:
    """Represents a captured malware sample with all analysis data"""
    capture_id: str
    timestamp: datetime
    source_url: str
    source_ip: str
    filename: str
    file_size: int
    file_type: str
    hashes: Dict[str, str]
    is_packed: bool
    packer_type: PackerType
    is_obfuscated: bool
    obfuscation_type: ObfuscationType
    category: MalwareCategory
    threat_level: str
    raw_data: bytes
    unpacked_data: Optional[bytes]
    decrypted_data: Optional[bytes]
    extracted_strings: List[str]
    extracted_urls: List[str]
    extracted_ips: List[str]
    extracted_domains: List[str]
    pe_info: Dict[str, Any]
    yara_matches: List[str]
    mitre_techniques: List[Dict[str, str]]
    code_sections: List[Dict[str, Any]]
    hex_dump: str
    disassembly: str
    decompiled_code: str
    analysis_notes: List[str]


@dataclass
class UnpackResult:
    """Result of unpacking operation"""
    success: bool
    packer_detected: PackerType
    original_size: int
    unpacked_size: int
    unpacked_data: Optional[bytes]
    error_message: str = ""


@dataclass
class DecryptResult:
    """Result of decryption operation"""
    success: bool
    obfuscation_detected: ObfuscationType
    decryption_key: Optional[str]
    decrypted_data: Optional[bytes]
    decrypted_strings: List[str] = field(default_factory=list)
    error_message: str = ""


class MalwareCaptureEngine:
    """Engine for capturing malware from URLs"""
    
    QUARANTINE_DIR = "/var/lib/tyranthos/quarantine"
    
    def __init__(self):
        self.captured_samples: Dict[str, CapturedMalware] = {}
        self._lock = threading.Lock()
        os.makedirs(self.QUARANTINE_DIR, exist_ok=True)
    
    def capture_from_url(self, url: str, timeout: int = 30) -> Optional[Tuple[bytes, str]]:
        """Capture malware sample from URL"""
        logger.info(f"Capturing malware from: {url}")
        
        try:
            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
            
            request = urllib.request.Request(url, headers=headers)
            
            with urllib.request.urlopen(request, timeout=timeout, context=ctx) as response:
                data = response.read()
                content_type = response.headers.get("Content-Type", "application/octet-stream")
                filename = self._extract_filename(url, response.headers)
                
                logger.info(f"Captured {len(data)} bytes from {url}")
                return data, filename
                
        except urllib.error.URLError as e:
            logger.error(f"URL error capturing {url}: {e}")
        except urllib.error.HTTPError as e:
            logger.error(f"HTTP error capturing {url}: {e.code}")
        except Exception as e:
            logger.error(f"Error capturing {url}: {e}")
        
        return None
    
    def _extract_filename(self, url: str, headers) -> str:
        """Extract filename from URL or headers"""
        content_disp = headers.get("Content-Disposition", "")
        if "filename=" in content_disp:
            match = re.search(r'filename="?([^";\s]+)"?', content_disp)
            if match:
                return match.group(1)
        
        path = url.split("?")[0]
        filename = path.split("/")[-1]
        if filename:
            return filename
        
        return f"sample_{hashlib.md5(url.encode()).hexdigest()[:8]}"
    
    def save_to_quarantine(self, data: bytes, filename: str) -> str:
        """Save captured sample to quarantine directory"""
        safe_filename = re.sub(r'[^\w\-_\.]', '_', filename)
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        quarantine_path = os.path.join(
            self.QUARANTINE_DIR,
            f"{timestamp}_{safe_filename}"
        )
        
        with open(quarantine_path, "wb") as f:
            f.write(data)
        
        logger.info(f"Saved sample to quarantine: {quarantine_path}")
        return quarantine_path


class PackerDetector:
    """Detects and identifies packers in executables"""
    
    PACKER_SIGNATURES = {
        PackerType.UPX: [
            b"UPX0", b"UPX1", b"UPX2", b"UPX!",
            b"\x55\x50\x58\x30", b"\x55\x50\x58\x31"
        ],
        PackerType.MPRESS: [
            b"MPRESS1", b"MPRESS2", b".MPRESS"
        ],
        PackerType.ASPACK: [
            b".aspack", b"ASPack", b".adata"
        ],
        PackerType.PECOMPACT: [
            b"PEC2", b"PECompact2", b"pec1", b"pec2"
        ],
        PackerType.THEMIDA: [
            b"Themida", b".themida", b"WinLicense"
        ],
        PackerType.VMPROTECT: [
            b"VMProtect", b".vmp0", b".vmp1", b".vmp2"
        ],
        PackerType.PETITE: [
            b".petite", b"petite"
        ],
        PackerType.FSG: [
            b"FSG!", b".FSG"
        ],
        PackerType.NSPACK: [
            b".nsp0", b".nsp1", b".nsp2", b"NsPack"
        ],
    }
    
    def detect(self, data: bytes) -> Tuple[bool, PackerType]:
        """Detect if file is packed and identify packer"""
        for packer_type, signatures in self.PACKER_SIGNATURES.items():
            for sig in signatures:
                if sig in data:
                    logger.info(f"Detected packer: {packer_type.value}")
                    return True, packer_type
        
        entropy = self._calculate_entropy(data)
        if entropy > 7.5:
            logger.info(f"High entropy ({entropy:.2f}) suggests packing")
            return True, PackerType.UNKNOWN
        
        return False, PackerType.UNKNOWN
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0.0
        
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        entropy = 0.0
        data_len = len(data)
        import math
        for count in byte_counts:
            if count > 0:
                probability = count / data_len
                entropy -= probability * math.log2(probability)
        
        return entropy


class MalwareUnpacker:
    """Unpacks packed executables"""
    
    def __init__(self):
        self.packer_detector = PackerDetector()
    
    def unpack(self, data: bytes, packer_type: PackerType = PackerType.UNKNOWN) -> UnpackResult:
        """Unpack a packed executable"""
        original_size = len(data)
        
        if packer_type == PackerType.UNKNOWN:
            is_packed, detected_packer = self.packer_detector.detect(data)
            if not is_packed:
                return UnpackResult(
                    success=True,
                    packer_detected=PackerType.UNKNOWN,
                    original_size=original_size,
                    unpacked_size=original_size,
                    unpacked_data=data,
                    error_message="File does not appear to be packed"
                )
            packer_type = detected_packer
        
        if packer_type == PackerType.UPX:
            return self._unpack_upx(data)
        elif packer_type in [PackerType.MPRESS, PackerType.ASPACK, PackerType.PECOMPACT]:
            return self._unpack_generic_pe(data, packer_type)
        else:
            return self._attempt_generic_unpack(data, packer_type)
    
    def _unpack_upx(self, data: bytes) -> UnpackResult:
        """Unpack UPX packed executable"""
        logger.info("Attempting UPX unpacking...")
        
        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".exe") as tmp_in:
                tmp_in.write(data)
                tmp_in_path = tmp_in.name
            
            tmp_out_path = tmp_in_path + ".unpacked"
            
            try:
                result = subprocess.run(
                    ["upx", "-d", "-o", tmp_out_path, tmp_in_path],
                    capture_output=True,
                    timeout=60
                )
                
                if result.returncode == 0 and os.path.exists(tmp_out_path):
                    with open(tmp_out_path, "rb") as f:
                        unpacked_data = f.read()
                    
                    os.unlink(tmp_in_path)
                    os.unlink(tmp_out_path)
                    
                    logger.info(f"UPX unpacking successful: {len(data)} -> {len(unpacked_data)} bytes")
                    return UnpackResult(
                        success=True,
                        packer_detected=PackerType.UPX,
                        original_size=len(data),
                        unpacked_size=len(unpacked_data),
                        unpacked_data=unpacked_data
                    )
            except subprocess.TimeoutExpired:
                logger.warning("UPX unpacking timed out")
            except FileNotFoundError:
                logger.warning("UPX tool not found, using manual unpacking")
            finally:
                if os.path.exists(tmp_in_path):
                    os.unlink(tmp_in_path)
                if os.path.exists(tmp_out_path):
                    os.unlink(tmp_out_path)
            
            return self._manual_upx_unpack(data)
            
        except Exception as e:
            logger.error(f"UPX unpacking failed: {e}")
            return UnpackResult(
                success=False,
                packer_detected=PackerType.UPX,
                original_size=len(data),
                unpacked_size=0,
                unpacked_data=None,
                error_message=str(e)
            )
    
    def _manual_upx_unpack(self, data: bytes) -> UnpackResult:
        """Manual UPX unpacking without external tool"""
        logger.info("Attempting manual UPX unpacking...")
        
        try:
            upx_header_offset = data.find(b"UPX!")
            if upx_header_offset == -1:
                for sig in [b"UPX0", b"UPX1", b"UPX2"]:
                    offset = data.find(sig)
                    if offset != -1:
                        upx_header_offset = offset
                        break
            
            if upx_header_offset == -1:
                return UnpackResult(
                    success=False,
                    packer_detected=PackerType.UPX,
                    original_size=len(data),
                    unpacked_size=0,
                    unpacked_data=None,
                    error_message="UPX header not found"
                )
            
            compressed_sections = []
            section_pattern = re.compile(b'UPX[012]')
            for match in section_pattern.finditer(data):
                section_start = match.start()
                section_end = data.find(b'\x00' * 16, section_start + 100)
                if section_end == -1:
                    section_end = len(data)
                compressed_sections.append(data[section_start:section_end])
            
            unpacked_parts = []
            for section in compressed_sections:
                try:
                    decompressed = zlib.decompress(section[8:], -zlib.MAX_WBITS)
                    unpacked_parts.append(decompressed)
                except zlib.error:
                    try:
                        decompressed = self._lzma_decompress(section[8:])
                        if decompressed:
                            unpacked_parts.append(decompressed)
                    except:
                        unpacked_parts.append(section)
            
            if unpacked_parts:
                unpacked_data = b''.join(unpacked_parts)
                return UnpackResult(
                    success=True,
                    packer_detected=PackerType.UPX,
                    original_size=len(data),
                    unpacked_size=len(unpacked_data),
                    unpacked_data=unpacked_data
                )
            
            return UnpackResult(
                success=False,
                packer_detected=PackerType.UPX,
                original_size=len(data),
                unpacked_size=0,
                unpacked_data=data,
                error_message="Manual UPX unpacking incomplete - returning original"
            )
            
        except Exception as e:
            logger.error(f"Manual UPX unpacking failed: {e}")
            return UnpackResult(
                success=False,
                packer_detected=PackerType.UPX,
                original_size=len(data),
                unpacked_size=0,
                unpacked_data=data,
                error_message=str(e)
            )
    
    def _lzma_decompress(self, data: bytes) -> Optional[bytes]:
        """Attempt LZMA decompression"""
        try:
            import lzma
            return lzma.decompress(data)
        except:
            return None
    
    def _unpack_generic_pe(self, data: bytes, packer_type: PackerType) -> UnpackResult:
        """Generic PE unpacking for various packers"""
        logger.info(f"Attempting generic PE unpacking for {packer_type.value}...")
        
        try:
            if not data.startswith(b'MZ'):
                return UnpackResult(
                    success=False,
                    packer_detected=packer_type,
                    original_size=len(data),
                    unpacked_size=0,
                    unpacked_data=None,
                    error_message="Not a valid PE file"
                )
            
            pe_offset = struct.unpack('<I', data[60:64])[0]
            
            if len(data) < pe_offset + 248:
                return UnpackResult(
                    success=False,
                    packer_detected=packer_type,
                    original_size=len(data),
                    unpacked_size=0,
                    unpacked_data=None,
                    error_message="Invalid PE structure"
                )
            
            num_sections = struct.unpack('<H', data[pe_offset + 6:pe_offset + 8])[0]
            optional_header_size = struct.unpack('<H', data[pe_offset + 20:pe_offset + 22])[0]
            
            section_table_offset = pe_offset + 24 + optional_header_size
            
            unpacked_sections = []
            for i in range(num_sections):
                section_offset = section_table_offset + (i * 40)
                if section_offset + 40 > len(data):
                    break
                
                section_name = data[section_offset:section_offset + 8].rstrip(b'\x00')
                virtual_size = struct.unpack('<I', data[section_offset + 8:section_offset + 12])[0]
                raw_size = struct.unpack('<I', data[section_offset + 16:section_offset + 20])[0]
                raw_offset = struct.unpack('<I', data[section_offset + 20:section_offset + 24])[0]
                
                if raw_offset + raw_size <= len(data):
                    section_data = data[raw_offset:raw_offset + raw_size]
                    
                    try:
                        decompressed = zlib.decompress(section_data, -zlib.MAX_WBITS)
                        unpacked_sections.append(decompressed)
                    except:
                        unpacked_sections.append(section_data)
            
            if unpacked_sections:
                header = data[:section_table_offset + (num_sections * 40)]
                unpacked_data = header + b''.join(unpacked_sections)
                
                return UnpackResult(
                    success=True,
                    packer_detected=packer_type,
                    original_size=len(data),
                    unpacked_size=len(unpacked_data),
                    unpacked_data=unpacked_data
                )
            
            return UnpackResult(
                success=False,
                packer_detected=packer_type,
                original_size=len(data),
                unpacked_size=0,
                unpacked_data=data,
                error_message="Could not unpack sections"
            )
            
        except Exception as e:
            logger.error(f"Generic PE unpacking failed: {e}")
            return UnpackResult(
                success=False,
                packer_detected=packer_type,
                original_size=len(data),
                unpacked_size=0,
                unpacked_data=data,
                error_message=str(e)
            )
    
    def _attempt_generic_unpack(self, data: bytes, packer_type: PackerType) -> UnpackResult:
        """Attempt generic unpacking for unknown packers"""
        logger.info(f"Attempting generic unpacking for {packer_type.value}...")
        
        try:
            decompressed = zlib.decompress(data)
            return UnpackResult(
                success=True,
                packer_detected=packer_type,
                original_size=len(data),
                unpacked_size=len(decompressed),
                unpacked_data=decompressed
            )
        except:
            pass
        
        try:
            decompressed = zlib.decompress(data, -zlib.MAX_WBITS)
            return UnpackResult(
                success=True,
                packer_detected=packer_type,
                original_size=len(data),
                unpacked_size=len(decompressed),
                unpacked_data=decompressed
            )
        except:
            pass
        
        try:
            import lzma
            decompressed = lzma.decompress(data)
            return UnpackResult(
                success=True,
                packer_detected=packer_type,
                original_size=len(data),
                unpacked_size=len(decompressed),
                unpacked_data=decompressed
            )
        except:
            pass
        
        return UnpackResult(
            success=False,
            packer_detected=packer_type,
            original_size=len(data),
            unpacked_size=len(data),
            unpacked_data=data,
            error_message="Could not unpack - returning original data"
        )


class ObfuscationDetector:
    """Detects obfuscation techniques in code"""
    
    def detect(self, data: bytes) -> Tuple[bool, ObfuscationType]:
        """Detect obfuscation type"""
        data_str = data.decode('utf-8', errors='ignore')
        
        if self._detect_base64(data_str):
            return True, ObfuscationType.BASE64
        
        if self._detect_xor(data):
            return True, ObfuscationType.XOR
        
        if self._detect_rot13(data_str):
            return True, ObfuscationType.ROT13
        
        if self._detect_aes_markers(data):
            return True, ObfuscationType.AES
        
        if self._detect_rc4_markers(data):
            return True, ObfuscationType.RC4
        
        return False, ObfuscationType.NONE
    
    def _detect_base64(self, data_str: str) -> bool:
        """Detect Base64 encoded content"""
        base64_pattern = re.compile(r'[A-Za-z0-9+/]{40,}={0,2}')
        matches = base64_pattern.findall(data_str)
        
        for match in matches:
            try:
                decoded = base64.b64decode(match)
                if len(decoded) > 10 and self._is_meaningful(decoded):
                    return True
            except:
                continue
        
        return False
    
    def _detect_xor(self, data: bytes) -> bool:
        """Detect XOR obfuscation"""
        for key in range(1, 256):
            decoded = bytes([b ^ key for b in data[:100]])
            if self._contains_strings(decoded):
                return True
        
        return False
    
    def _detect_rot13(self, data_str: str) -> bool:
        """Detect ROT13 encoding"""
        import codecs
        decoded = codecs.decode(data_str[:500], 'rot_13')
        
        keywords = ['http', 'www', 'exe', 'dll', 'cmd', 'shell', 'password']
        for keyword in keywords:
            if keyword in decoded.lower():
                return True
        
        return False
    
    def _detect_aes_markers(self, data: bytes) -> bool:
        """Detect AES encryption markers"""
        aes_markers = [
            b'AES', b'Rijndael', b'aes_', b'AES_',
            b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f'
        ]
        
        for marker in aes_markers:
            if marker in data:
                return True
        
        return False
    
    def _detect_rc4_markers(self, data: bytes) -> bool:
        """Detect RC4 encryption markers"""
        rc4_markers = [b'RC4', b'rc4_', b'arcfour']
        
        for marker in rc4_markers:
            if marker in data:
                return True
        
        return False
    
    def _is_meaningful(self, data: bytes) -> bool:
        """Check if decoded data is meaningful"""
        try:
            text = data.decode('utf-8', errors='ignore')
            printable_ratio = sum(1 for c in text if c.isprintable()) / len(text)
            return printable_ratio > 0.7
        except:
            return False
    
    def _contains_strings(self, data: bytes) -> bool:
        """Check if data contains meaningful strings"""
        keywords = [b'http', b'www', b'exe', b'dll', b'cmd', b'shell']
        for keyword in keywords:
            if keyword in data.lower():
                return True
        return False


class MalwareDecryptor:
    """Decrypts obfuscated malware code"""
    
    def __init__(self):
        self.obfuscation_detector = ObfuscationDetector()
    
    def decrypt(self, data: bytes, obfuscation_type: ObfuscationType = ObfuscationType.NONE) -> DecryptResult:
        """Decrypt obfuscated data"""
        if obfuscation_type == ObfuscationType.NONE:
            is_obfuscated, detected_type = self.obfuscation_detector.detect(data)
            if not is_obfuscated:
                return DecryptResult(
                    success=True,
                    obfuscation_detected=ObfuscationType.NONE,
                    decryption_key=None,
                    decrypted_data=data,
                    error_message="No obfuscation detected"
                )
            obfuscation_type = detected_type
        
        if obfuscation_type == ObfuscationType.BASE64:
            return self._decrypt_base64(data)
        elif obfuscation_type == ObfuscationType.XOR:
            return self._decrypt_xor(data)
        elif obfuscation_type == ObfuscationType.ROT13:
            return self._decrypt_rot13(data)
        elif obfuscation_type == ObfuscationType.AES:
            return self._attempt_aes_decrypt(data)
        elif obfuscation_type == ObfuscationType.RC4:
            return self._attempt_rc4_decrypt(data)
        else:
            return DecryptResult(
                success=False,
                obfuscation_detected=obfuscation_type,
                decryption_key=None,
                decrypted_data=data,
                error_message="Unknown obfuscation type"
            )
    
    def _decrypt_base64(self, data: bytes) -> DecryptResult:
        """Decrypt Base64 encoded content"""
        data_str = data.decode('utf-8', errors='ignore')
        
        base64_pattern = re.compile(r'[A-Za-z0-9+/]{20,}={0,2}')
        matches = base64_pattern.findall(data_str)
        
        decrypted_strings = []
        for match in matches:
            try:
                decoded = base64.b64decode(match)
                decoded_str = decoded.decode('utf-8', errors='ignore')
                if len(decoded_str) > 5:
                    decrypted_strings.append(decoded_str)
            except:
                continue
        
        if decrypted_strings:
            decrypted_data = '\n'.join(decrypted_strings).encode('utf-8')
            return DecryptResult(
                success=True,
                obfuscation_detected=ObfuscationType.BASE64,
                decryption_key="base64",
                decrypted_data=decrypted_data,
                decrypted_strings=decrypted_strings
            )
        
        return DecryptResult(
            success=False,
            obfuscation_detected=ObfuscationType.BASE64,
            decryption_key=None,
            decrypted_data=data,
            error_message="No valid Base64 content found"
        )
    
    def _decrypt_xor(self, data: bytes) -> DecryptResult:
        """Decrypt XOR obfuscated content"""
        best_key = None
        best_score = 0
        best_decrypted = None
        
        for key in range(1, 256):
            decrypted = bytes([b ^ key for b in data])
            score = self._score_decryption(decrypted)
            
            if score > best_score:
                best_score = score
                best_key = key
                best_decrypted = decrypted
        
        for key_len in [2, 4, 8, 16]:
            for key_start in range(256):
                key = bytes([key_start + i for i in range(key_len)])
                decrypted = bytes([data[i] ^ key[i % key_len] for i in range(len(data))])
                score = self._score_decryption(decrypted)
                
                if score > best_score:
                    best_score = score
                    best_key = key.hex()
                    best_decrypted = decrypted
        
        if best_decrypted and best_score > 0:
            return DecryptResult(
                success=True,
                obfuscation_detected=ObfuscationType.XOR,
                decryption_key=str(best_key),
                decrypted_data=best_decrypted,
                decrypted_strings=self._extract_strings(best_decrypted)
            )
        
        return DecryptResult(
            success=False,
            obfuscation_detected=ObfuscationType.XOR,
            decryption_key=None,
            decrypted_data=data,
            error_message="Could not find XOR key"
        )
    
    def _decrypt_rot13(self, data: bytes) -> DecryptResult:
        """Decrypt ROT13 encoded content"""
        import codecs
        
        data_str = data.decode('utf-8', errors='ignore')
        decrypted_str = codecs.decode(data_str, 'rot_13')
        decrypted_data = decrypted_str.encode('utf-8')
        
        return DecryptResult(
            success=True,
            obfuscation_detected=ObfuscationType.ROT13,
            decryption_key="rot13",
            decrypted_data=decrypted_data,
            decrypted_strings=self._extract_strings(decrypted_data)
        )
    
    def _attempt_aes_decrypt(self, data: bytes) -> DecryptResult:
        """Attempt AES decryption with common keys"""
        common_keys = [
            b'\x00' * 16,
            b'\x00' * 32,
            b'0123456789abcdef',
            b'abcdefghijklmnop',
            b'password12345678',
        ]
        
        try:
            from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
            from cryptography.hazmat.backends import default_backend
            
            for key in common_keys:
                for iv in [b'\x00' * 16, data[:16]]:
                    try:
                        cipher = Cipher(
                            algorithms.AES(key[:32].ljust(32, b'\x00')),
                            modes.CBC(iv),
                            backend=default_backend()
                        )
                        decryptor = cipher.decryptor()
                        decrypted = decryptor.update(data[16:]) + decryptor.finalize()
                        
                        if self._score_decryption(decrypted) > 0:
                            return DecryptResult(
                                success=True,
                                obfuscation_detected=ObfuscationType.AES,
                                decryption_key=key.hex(),
                                decrypted_data=decrypted,
                                decrypted_strings=self._extract_strings(decrypted)
                            )
                    except:
                        continue
        except ImportError:
            logger.warning("cryptography library not available for AES decryption")
        
        return DecryptResult(
            success=False,
            obfuscation_detected=ObfuscationType.AES,
            decryption_key=None,
            decrypted_data=data,
            error_message="Could not decrypt AES - key not found"
        )
    
    def _attempt_rc4_decrypt(self, data: bytes) -> DecryptResult:
        """Attempt RC4 decryption with common keys"""
        common_keys = [
            b'password',
            b'secret',
            b'key',
            b'admin',
            b'root',
        ]
        
        for key in common_keys:
            decrypted = self._rc4_decrypt(data, key)
            if self._score_decryption(decrypted) > 0:
                return DecryptResult(
                    success=True,
                    obfuscation_detected=ObfuscationType.RC4,
                    decryption_key=key.decode('utf-8', errors='ignore'),
                    decrypted_data=decrypted,
                    decrypted_strings=self._extract_strings(decrypted)
                )
        
        return DecryptResult(
            success=False,
            obfuscation_detected=ObfuscationType.RC4,
            decryption_key=None,
            decrypted_data=data,
            error_message="Could not decrypt RC4 - key not found"
        )
    
    def _rc4_decrypt(self, data: bytes, key: bytes) -> bytes:
        """RC4 decryption implementation"""
        S = list(range(256))
        j = 0
        
        for i in range(256):
            j = (j + S[i] + key[i % len(key)]) % 256
            S[i], S[j] = S[j], S[i]
        
        i = j = 0
        result = []
        
        for byte in data:
            i = (i + 1) % 256
            j = (j + S[i]) % 256
            S[i], S[j] = S[j], S[i]
            result.append(byte ^ S[(S[i] + S[j]) % 256])
        
        return bytes(result)
    
    def _score_decryption(self, data: bytes) -> int:
        """Score decryption quality based on meaningful content"""
        score = 0
        
        keywords = [
            b'http', b'https', b'www', b'exe', b'dll', b'cmd', b'shell',
            b'password', b'user', b'admin', b'root', b'system', b'windows',
            b'linux', b'socket', b'connect', b'download', b'upload'
        ]
        
        data_lower = data.lower()
        for keyword in keywords:
            if keyword in data_lower:
                score += 10
        
        try:
            text = data.decode('utf-8', errors='ignore')
            printable_count = sum(1 for c in text if c.isprintable())
            if printable_count / len(text) > 0.7:
                score += 20
        except:
            pass
        
        return score
    
    def _extract_strings(self, data: bytes) -> List[str]:
        """Extract readable strings from data"""
        strings = []
        
        pattern = re.compile(b'[\x20-\x7e]{4,}')
        for match in pattern.finditer(data):
            try:
                s = match.group().decode('ascii')
                strings.append(s)
            except:
                continue
        
        return strings[:100]


class CodeExtractor:
    """Extracts and formats code from malware samples"""
    
    def extract_code_sections(self, data: bytes) -> List[Dict[str, Any]]:
        """Extract code sections from PE file"""
        sections = []
        
        if not data.startswith(b'MZ'):
            sections.append({
                "name": "raw_data",
                "offset": 0,
                "size": len(data),
                "entropy": self._calculate_entropy(data),
                "characteristics": "raw binary",
                "data": data[:10000]
            })
            return sections
        
        try:
            pe_offset = struct.unpack('<I', data[60:64])[0]
            num_sections = struct.unpack('<H', data[pe_offset + 6:pe_offset + 8])[0]
            optional_header_size = struct.unpack('<H', data[pe_offset + 20:pe_offset + 22])[0]
            section_table_offset = pe_offset + 24 + optional_header_size
            
            for i in range(num_sections):
                section_offset = section_table_offset + (i * 40)
                if section_offset + 40 > len(data):
                    break
                
                section_name = data[section_offset:section_offset + 8].rstrip(b'\x00').decode('utf-8', errors='ignore')
                virtual_size = struct.unpack('<I', data[section_offset + 8:section_offset + 12])[0]
                raw_size = struct.unpack('<I', data[section_offset + 16:section_offset + 20])[0]
                raw_offset = struct.unpack('<I', data[section_offset + 20:section_offset + 24])[0]
                characteristics = struct.unpack('<I', data[section_offset + 36:section_offset + 40])[0]
                
                if raw_offset + raw_size <= len(data):
                    section_data = data[raw_offset:raw_offset + raw_size]
                    
                    sections.append({
                        "name": section_name,
                        "offset": raw_offset,
                        "size": raw_size,
                        "virtual_size": virtual_size,
                        "entropy": self._calculate_entropy(section_data),
                        "characteristics": self._parse_characteristics(characteristics),
                        "data": section_data[:10000]
                    })
            
        except Exception as e:
            logger.error(f"Error extracting sections: {e}")
            sections.append({
                "name": "raw_data",
                "offset": 0,
                "size": len(data),
                "entropy": self._calculate_entropy(data),
                "characteristics": "parse error",
                "data": data[:10000]
            })
        
        return sections
    
    def generate_hex_dump(self, data: bytes, max_bytes: int = 4096) -> str:
        """Generate formatted hex dump"""
        lines = []
        data = data[:max_bytes]
        
        for i in range(0, len(data), 16):
            chunk = data[i:i + 16]
            hex_part = ' '.join(f'{b:02x}' for b in chunk)
            ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
            lines.append(f'{i:08x}  {hex_part:<48}  |{ascii_part}|')
        
        return '\n'.join(lines)
    
    def generate_disassembly(self, data: bytes, max_instructions: int = 500) -> str:
        """Generate disassembly output"""
        lines = []
        
        if not data.startswith(b'MZ'):
            lines.append("; Not a PE file - raw disassembly")
            lines.append("")
            
            offset = 0
            for i in range(0, min(len(data), max_instructions * 4), 4):
                chunk = data[i:i + 4]
                hex_bytes = ' '.join(f'{b:02x}' for b in chunk)
                lines.append(f"0x{offset:08x}:  {hex_bytes:<12}")
                offset += 4
            
            return '\n'.join(lines)
        
        try:
            pe_offset = struct.unpack('<I', data[60:64])[0]
            
            machine = struct.unpack('<H', data[pe_offset + 4:pe_offset + 6])[0]
            if machine == 0x8664:
                arch = "AMD64"
            elif machine == 0x14c:
                arch = "i386"
            else:
                arch = f"Unknown (0x{machine:x})"
            
            entry_rva = struct.unpack('<I', data[pe_offset + 40:pe_offset + 44])[0]
            
            lines.append(f"; Architecture: {arch}")
            lines.append(f"; Entry Point RVA: 0x{entry_rva:08x}")
            lines.append("")
            lines.append("; Disassembly from entry point:")
            lines.append("")
            
            num_sections = struct.unpack('<H', data[pe_offset + 6:pe_offset + 8])[0]
            optional_header_size = struct.unpack('<H', data[pe_offset + 20:pe_offset + 22])[0]
            section_table_offset = pe_offset + 24 + optional_header_size
            
            entry_offset = 0
            for i in range(num_sections):
                section_offset = section_table_offset + (i * 40)
                if section_offset + 40 > len(data):
                    break
                
                virtual_address = struct.unpack('<I', data[section_offset + 12:section_offset + 16])[0]
                raw_size = struct.unpack('<I', data[section_offset + 16:section_offset + 20])[0]
                raw_offset = struct.unpack('<I', data[section_offset + 20:section_offset + 24])[0]
                
                if virtual_address <= entry_rva < virtual_address + raw_size:
                    entry_offset = raw_offset + (entry_rva - virtual_address)
                    break
            
            if entry_offset == 0:
                entry_offset = min(entry_rva, len(data) - 100)
            
            code_data = data[entry_offset:entry_offset + (max_instructions * 4)]
            
            offset = entry_offset
            instruction_count = 0
            i = 0
            
            while i < len(code_data) and instruction_count < max_instructions:
                opcode = code_data[i]
                
                instruction, length = self._decode_instruction(code_data[i:i + 15], arch)
                hex_bytes = ' '.join(f'{b:02x}' for b in code_data[i:i + length])
                
                lines.append(f"0x{offset:08x}:  {hex_bytes:<24}  {instruction}")
                
                offset += length
                i += length
                instruction_count += 1
            
        except Exception as e:
            lines.append(f"; Error generating disassembly: {e}")
            lines.append("")
            
            for i in range(0, min(len(data), 256), 4):
                chunk = data[i:i + 4]
                hex_bytes = ' '.join(f'{b:02x}' for b in chunk)
                lines.append(f"0x{i:08x}:  {hex_bytes}")
        
        return '\n'.join(lines)
    
    def _decode_instruction(self, data: bytes, arch: str) -> Tuple[str, int]:
        """Decode a single instruction (simplified)"""
        if len(data) < 1:
            return "db 0x00", 1
        
        opcode = data[0]
        
        x86_opcodes = {
            0x50: ("push eax", 1),
            0x51: ("push ecx", 1),
            0x52: ("push edx", 1),
            0x53: ("push ebx", 1),
            0x54: ("push esp", 1),
            0x55: ("push ebp", 1),
            0x56: ("push esi", 1),
            0x57: ("push edi", 1),
            0x58: ("pop eax", 1),
            0x59: ("pop ecx", 1),
            0x5a: ("pop edx", 1),
            0x5b: ("pop ebx", 1),
            0x5c: ("pop esp", 1),
            0x5d: ("pop ebp", 1),
            0x5e: ("pop esi", 1),
            0x5f: ("pop edi", 1),
            0x90: ("nop", 1),
            0xc3: ("ret", 1),
            0xcc: ("int3", 1),
            0xc9: ("leave", 1),
            0x89: ("mov r/m32, r32", 2),
            0x8b: ("mov r32, r/m32", 2),
            0xb8: ("mov eax, imm32", 5),
            0xb9: ("mov ecx, imm32", 5),
            0xba: ("mov edx, imm32", 5),
            0xbb: ("mov ebx, imm32", 5),
            0xe8: ("call rel32", 5),
            0xe9: ("jmp rel32", 5),
            0xeb: ("jmp rel8", 2),
            0x74: ("je rel8", 2),
            0x75: ("jne rel8", 2),
            0x83: ("add/sub r/m32, imm8", 3),
            0xff: ("call/jmp r/m32", 2),
        }
        
        if opcode in x86_opcodes:
            return x86_opcodes[opcode]
        
        return f"db 0x{opcode:02x}", 1
    
    def generate_decompiled_code(self, data: bytes, strings: List[str]) -> str:
        """Generate pseudo-decompiled code representation"""
        lines = []
        lines.append("// Pseudo-decompiled code representation")
        lines.append("// Generated by TYRANTHOS Malware Analysis Engine")
        lines.append("")
        
        if data.startswith(b'MZ'):
            lines.append("// PE Executable Analysis")
            lines.append("")
            
            try:
                pe_offset = struct.unpack('<I', data[60:64])[0]
                machine = struct.unpack('<H', data[pe_offset + 4:pe_offset + 6])[0]
                
                if machine == 0x8664:
                    lines.append("// Target: Windows x64")
                elif machine == 0x14c:
                    lines.append("// Target: Windows x86")
                
                lines.append("")
                lines.append("int main() {")
                lines.append("    // Entry point code")
                lines.append("")
                
                if strings:
                    lines.append("    // Extracted strings suggest:")
                    for s in strings[:20]:
                        if 'http' in s.lower():
                            lines.append(f'    // Network communication: "{s[:60]}"')
                        elif 'cmd' in s.lower() or 'shell' in s.lower():
                            lines.append(f'    // Command execution: "{s[:60]}"')
                        elif 'password' in s.lower() or 'user' in s.lower():
                            lines.append(f'    // Credential access: "{s[:60]}"')
                        elif 'reg' in s.lower():
                            lines.append(f'    // Registry access: "{s[:60]}"')
                        elif 'file' in s.lower() or 'write' in s.lower():
                            lines.append(f'    // File operation: "{s[:60]}"')
                
                lines.append("")
                lines.append("    return 0;")
                lines.append("}")
                
            except Exception as e:
                lines.append(f"// Error parsing PE: {e}")
        
        else:
            lines.append("// Non-PE binary or script")
            lines.append("")
            
            data_str = data.decode('utf-8', errors='ignore')
            
            if 'function' in data_str or 'var ' in data_str or 'const ' in data_str:
                lines.append("// JavaScript/TypeScript detected")
                lines.append(data_str[:5000])
            elif 'def ' in data_str or 'import ' in data_str:
                lines.append("// Python detected")
                lines.append(data_str[:5000])
            elif '<?php' in data_str:
                lines.append("// PHP detected")
                lines.append(data_str[:5000])
            elif '<script' in data_str.lower():
                lines.append("// HTML with embedded script")
                lines.append(data_str[:5000])
            else:
                lines.append("// Raw binary data")
                lines.append(f"// Size: {len(data)} bytes")
        
        return '\n'.join(lines)
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy"""
        if not data:
            return 0.0
        
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        entropy = 0.0
        data_len = len(data)
        import math
        for count in byte_counts:
            if count > 0:
                probability = count / data_len
                entropy -= probability * math.log2(probability)
        
        return round(entropy, 4)
    
    def _parse_characteristics(self, characteristics: int) -> str:
        """Parse PE section characteristics"""
        flags = []
        
        if characteristics & 0x00000020:
            flags.append("CODE")
        if characteristics & 0x00000040:
            flags.append("INITIALIZED_DATA")
        if characteristics & 0x00000080:
            flags.append("UNINITIALIZED_DATA")
        if characteristics & 0x20000000:
            flags.append("EXECUTE")
        if characteristics & 0x40000000:
            flags.append("READ")
        if characteristics & 0x80000000:
            flags.append("WRITE")
        
        return ' | '.join(flags) if flags else f"0x{characteristics:08x}"


class MalwareCaptureAnalysisEngine:
    """Main engine for malware capture and analysis"""
    
    DB_PATH = "/var/lib/tyranthos/malware_captures.db"
    
    def __init__(self):
        self.capture_engine = MalwareCaptureEngine()
        self.unpacker = MalwareUnpacker()
        self.decryptor = MalwareDecryptor()
        self.code_extractor = CodeExtractor()
        self.captured_samples: Dict[str, CapturedMalware] = {}
        self._lock = threading.Lock()
        self._init_database()
    
    def _init_database(self):
        """Initialize SQLite database for malware storage"""
        os.makedirs(os.path.dirname(self.DB_PATH), exist_ok=True)
        
        conn = sqlite3.connect(self.DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS malware_captures (
                capture_id TEXT PRIMARY KEY,
                timestamp TEXT NOT NULL,
                source_url TEXT NOT NULL,
                source_ip TEXT,
                filename TEXT NOT NULL,
                file_size INTEGER NOT NULL,
                file_type TEXT,
                md5_hash TEXT NOT NULL,
                sha256_hash TEXT NOT NULL,
                is_packed INTEGER,
                packer_type TEXT,
                is_obfuscated INTEGER,
                obfuscation_type TEXT,
                category TEXT,
                threat_level TEXT,
                yara_matches TEXT,
                mitre_techniques TEXT,
                extracted_strings TEXT,
                extracted_urls TEXT,
                extracted_ips TEXT,
                analysis_notes TEXT,
                quarantine_path TEXT
            )
        """)
        
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_captures_timestamp ON malware_captures(timestamp)
        """)
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_captures_hash ON malware_captures(sha256_hash)
        """)
        
        conn.commit()
        conn.close()
        logger.info(f"Malware capture database initialized at {self.DB_PATH}")
    
    def capture_and_analyze(self, url: str) -> Optional[CapturedMalware]:
        """Capture malware from URL and perform full analysis"""
        logger.info(f"Starting capture and analysis for: {url}")
        
        result = self.capture_engine.capture_from_url(url)
        if not result:
            logger.error(f"Failed to capture malware from {url}")
            return None
        
        data, filename = result
        
        quarantine_path = self.capture_engine.save_to_quarantine(data, filename)
        
        return self.analyze_sample(data, filename, url, quarantine_path)
    
    def analyze_sample(self, data: bytes, filename: str, source_url: str = "", 
                       quarantine_path: str = "") -> CapturedMalware:
        """Perform full analysis on malware sample"""
        capture_id = f"MAL-{hashlib.md5(data).hexdigest()[:12].upper()}"
        
        hashes = {
            "md5": hashlib.md5(data).hexdigest(),
            "sha1": hashlib.sha1(data).hexdigest(),
            "sha256": hashlib.sha256(data).hexdigest(),
            "sha512": hashlib.sha512(data).hexdigest(),
        }
        
        file_type = self._detect_file_type(data)
        
        is_packed, packer_type = self.unpacker.packer_detector.detect(data)
        
        unpacked_data = None
        if is_packed:
            unpack_result = self.unpacker.unpack(data, packer_type)
            if unpack_result.success:
                unpacked_data = unpack_result.unpacked_data
        
        analysis_data = unpacked_data if unpacked_data else data
        
        is_obfuscated, obfuscation_type = self.decryptor.obfuscation_detector.detect(analysis_data)
        
        decrypted_data = None
        decrypted_strings = []
        if is_obfuscated:
            decrypt_result = self.decryptor.decrypt(analysis_data, obfuscation_type)
            if decrypt_result.success:
                decrypted_data = decrypt_result.decrypted_data
                decrypted_strings = decrypt_result.decrypted_strings
        
        final_data = decrypted_data if decrypted_data else analysis_data
        
        strings = self._extract_strings(final_data)
        urls = self._extract_urls(final_data)
        ips = self._extract_ips(final_data)
        domains = self._extract_domains(final_data)
        
        pe_info = self._analyze_pe(data)
        
        category = self._classify_malware(strings, urls, ips, pe_info)
        threat_level = self._assess_threat_level(category, is_packed, is_obfuscated)
        
        yara_matches = self._run_yara_rules(data)
        mitre_techniques = self._map_to_mitre(category, strings)
        
        code_sections = self.code_extractor.extract_code_sections(final_data)
        hex_dump = self.code_extractor.generate_hex_dump(final_data)
        disassembly = self.code_extractor.generate_disassembly(final_data)
        decompiled = self.code_extractor.generate_decompiled_code(final_data, strings)
        
        source_ip = self._extract_ip_from_url(source_url)
        
        captured = CapturedMalware(
            capture_id=capture_id,
            timestamp=datetime.utcnow(),
            source_url=source_url,
            source_ip=source_ip,
            filename=filename,
            file_size=len(data),
            file_type=file_type,
            hashes=hashes,
            is_packed=is_packed,
            packer_type=packer_type,
            is_obfuscated=is_obfuscated,
            obfuscation_type=obfuscation_type,
            category=category,
            threat_level=threat_level,
            raw_data=data,
            unpacked_data=unpacked_data,
            decrypted_data=decrypted_data,
            extracted_strings=strings + decrypted_strings,
            extracted_urls=urls,
            extracted_ips=ips,
            extracted_domains=domains,
            pe_info=pe_info,
            yara_matches=yara_matches,
            mitre_techniques=mitre_techniques,
            code_sections=code_sections,
            hex_dump=hex_dump,
            disassembly=disassembly,
            decompiled_code=decompiled,
            analysis_notes=[]
        )
        
        with self._lock:
            self.captured_samples[capture_id] = captured
        
        self._save_to_database(captured, quarantine_path)
        
        logger.info(f"Analysis complete for {capture_id}: {category.value}, {threat_level}")
        return captured
    
    def _detect_file_type(self, data: bytes) -> str:
        """Detect file type from magic bytes"""
        if data.startswith(b'MZ'):
            return "PE32/PE32+"
        elif data.startswith(b'\x7fELF'):
            return "ELF"
        elif data.startswith(b'PK'):
            return "ZIP/JAR/APK"
        elif data.startswith(b'\xca\xfe\xba\xbe'):
            return "Java Class"
        elif data.startswith(b'%PDF'):
            return "PDF"
        elif data.startswith(b'\xd0\xcf\x11\xe0'):
            return "OLE/MS Office"
        elif b'<script' in data[:1000].lower():
            return "HTML/JavaScript"
        elif b'<?php' in data[:1000]:
            return "PHP"
        elif b'import ' in data[:1000] or b'def ' in data[:1000]:
            return "Python"
        elif b'function' in data[:1000] or b'var ' in data[:1000]:
            return "JavaScript"
        else:
            return "Unknown Binary"
    
    def _extract_strings(self, data: bytes, min_length: int = 4) -> List[str]:
        """Extract ASCII strings from binary"""
        strings = []
        pattern = re.compile(b'[\x20-\x7e]{' + str(min_length).encode() + b',}')
        
        for match in pattern.finditer(data):
            try:
                s = match.group().decode('ascii')
                strings.append(s)
            except:
                continue
        
        return strings[:500]
    
    def _extract_urls(self, data: bytes) -> List[str]:
        """Extract URLs from binary"""
        data_str = data.decode('utf-8', errors='ignore')
        url_pattern = re.compile(r'https?://[^\s<>"{}|\\^`\[\]]+')
        return list(set(url_pattern.findall(data_str)))[:100]
    
    def _extract_ips(self, data: bytes) -> List[str]:
        """Extract IP addresses from binary"""
        data_str = data.decode('utf-8', errors='ignore')
        ip_pattern = re.compile(r'\b(?:\d{1,3}\.){3}\d{1,3}\b')
        
        ips = []
        for ip in ip_pattern.findall(data_str):
            try:
                import ipaddress
                ipaddress.ip_address(ip)
                ips.append(ip)
            except:
                continue
        
        return list(set(ips))[:100]
    
    def _extract_domains(self, data: bytes) -> List[str]:
        """Extract domain names from binary"""
        data_str = data.decode('utf-8', errors='ignore')
        domain_pattern = re.compile(r'\b(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}\b')
        
        domains = []
        for domain in domain_pattern.findall(data_str):
            if '.' in domain and len(domain) > 4:
                domains.append(domain)
        
        return list(set(domains))[:100]
    
    def _extract_ip_from_url(self, url: str) -> str:
        """Extract IP from URL"""
        ip_pattern = re.compile(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})')
        match = ip_pattern.search(url)
        return match.group(1) if match else ""
    
    def _analyze_pe(self, data: bytes) -> Dict[str, Any]:
        """Analyze PE file structure"""
        pe_info = {
            "is_pe": False,
            "machine": None,
            "timestamp": None,
            "entry_point": None,
            "sections": [],
            "imports": [],
            "exports": []
        }
        
        if not data.startswith(b'MZ'):
            return pe_info
        
        pe_info["is_pe"] = True
        
        try:
            pe_offset = struct.unpack('<I', data[60:64])[0]
            
            machine = struct.unpack('<H', data[pe_offset + 4:pe_offset + 6])[0]
            machine_types = {
                0x14c: "i386",
                0x8664: "AMD64",
                0x1c0: "ARM",
                0xaa64: "ARM64"
            }
            pe_info["machine"] = machine_types.get(machine, f"Unknown (0x{machine:x})")
            
            timestamp = struct.unpack('<I', data[pe_offset + 8:pe_offset + 12])[0]
            if timestamp > 0:
                pe_info["timestamp"] = datetime.fromtimestamp(timestamp).isoformat()
            
            entry_rva = struct.unpack('<I', data[pe_offset + 40:pe_offset + 44])[0]
            pe_info["entry_point"] = f"0x{entry_rva:08x}"
            
            num_sections = struct.unpack('<H', data[pe_offset + 6:pe_offset + 8])[0]
            optional_header_size = struct.unpack('<H', data[pe_offset + 20:pe_offset + 22])[0]
            section_table_offset = pe_offset + 24 + optional_header_size
            
            for i in range(num_sections):
                section_offset = section_table_offset + (i * 40)
                if section_offset + 40 > len(data):
                    break
                
                section_name = data[section_offset:section_offset + 8].rstrip(b'\x00').decode('utf-8', errors='ignore')
                virtual_size = struct.unpack('<I', data[section_offset + 8:section_offset + 12])[0]
                raw_size = struct.unpack('<I', data[section_offset + 16:section_offset + 20])[0]
                
                pe_info["sections"].append({
                    "name": section_name,
                    "virtual_size": virtual_size,
                    "raw_size": raw_size
                })
            
        except Exception as e:
            logger.error(f"PE analysis error: {e}")
        
        return pe_info
    
    def _classify_malware(self, strings: List[str], urls: List[str], 
                          ips: List[str], pe_info: Dict[str, Any]) -> MalwareCategory:
        """Classify malware based on indicators"""
        all_strings = ' '.join(strings).lower()
        
        ransomware_indicators = ['encrypt', 'decrypt', 'bitcoin', 'ransom', 'payment', '.locked', '.encrypted', 'wallet']
        rat_indicators = ['keylog', 'screenshot', 'webcam', 'microphone', 'shell', 'execute', 'remote']
        trojan_indicators = ['download', 'upload', 'connect', 'socket', 'http', 'ftp', 'backdoor']
        worm_indicators = ['spread', 'propagate', 'network', 'share', 'usb', 'autorun']
        rootkit_indicators = ['hook', 'hide', 'stealth', 'kernel', 'driver', 'ssdt']
        cryptominer_indicators = ['stratum', 'mining', 'hashrate', 'pool', 'monero', 'bitcoin', 'xmr']
        botnet_indicators = ['bot', 'ddos', 'flood', 'attack', 'zombie', 'c2', 'command']
        
        scores = {
            MalwareCategory.RANSOMWARE: sum(1 for i in ransomware_indicators if i in all_strings),
            MalwareCategory.RAT: sum(1 for i in rat_indicators if i in all_strings),
            MalwareCategory.TROJAN: sum(1 for i in trojan_indicators if i in all_strings),
            MalwareCategory.WORM: sum(1 for i in worm_indicators if i in all_strings),
            MalwareCategory.ROOTKIT: sum(1 for i in rootkit_indicators if i in all_strings),
            MalwareCategory.CRYPTOMINER: sum(1 for i in cryptominer_indicators if i in all_strings),
            MalwareCategory.BOTNET: sum(1 for i in botnet_indicators if i in all_strings),
        }
        
        if urls:
            scores[MalwareCategory.TROJAN] += 2
        if ips:
            scores[MalwareCategory.BOTNET] += 1
        
        max_score = max(scores.values())
        if max_score >= 2:
            for category, score in scores.items():
                if score == max_score:
                    return category
        
        return MalwareCategory.UNKNOWN
    
    def _assess_threat_level(self, category: MalwareCategory, 
                             is_packed: bool, is_obfuscated: bool) -> str:
        """Assess threat level"""
        base_levels = {
            MalwareCategory.RANSOMWARE: "CRITICAL",
            MalwareCategory.RAT: "HIGH",
            MalwareCategory.ROOTKIT: "HIGH",
            MalwareCategory.BOTNET: "HIGH",
            MalwareCategory.TROJAN: "MEDIUM",
            MalwareCategory.WORM: "MEDIUM",
            MalwareCategory.CRYPTOMINER: "MEDIUM",
            MalwareCategory.SPYWARE: "MEDIUM",
            MalwareCategory.BACKDOOR: "HIGH",
            MalwareCategory.VIRUS: "MEDIUM",
            MalwareCategory.ADWARE: "LOW",
            MalwareCategory.UNKNOWN: "MEDIUM",
        }
        
        level = base_levels.get(category, "MEDIUM")
        
        if is_packed and is_obfuscated:
            if level == "MEDIUM":
                level = "HIGH"
            elif level == "LOW":
                level = "MEDIUM"
        
        return level
    
    def _run_yara_rules(self, data: bytes) -> List[str]:
        """Run YARA rules against sample"""
        matches = []
        
        data_str = data.decode('utf-8', errors='ignore').lower()
        
        if 'cmd.exe' in data_str or 'powershell' in data_str:
            matches.append("Suspicious_Commands")
        
        if b'UPX' in data:
            matches.append("Packed_UPX")
        
        btc_pattern = re.compile(r'[13][a-km-zA-HJ-NP-Z1-9]{25,34}')
        if btc_pattern.search(data_str):
            matches.append("Crypto_Wallet_Address")
        
        if 'encrypt' in data_str and ('aes' in data_str or 'rsa' in data_str):
            matches.append("Encryption_Capability")
        
        if 'keylog' in data_str or 'getasynckeystate' in data_str:
            matches.append("Keylogger_Capability")
        
        if 'screenshot' in data_str or 'bitblt' in data_str:
            matches.append("Screenshot_Capability")
        
        return matches
    
    def _map_to_mitre(self, category: MalwareCategory, strings: List[str]) -> List[Dict[str, str]]:
        """Map to MITRE ATT&CK techniques"""
        techniques = []
        
        category_mapping = {
            MalwareCategory.RANSOMWARE: [
                {"id": "T1486", "name": "Data Encrypted for Impact"},
                {"id": "T1490", "name": "Inhibit System Recovery"},
            ],
            MalwareCategory.RAT: [
                {"id": "T1059", "name": "Command and Scripting Interpreter"},
                {"id": "T1113", "name": "Screen Capture"},
                {"id": "T1056", "name": "Input Capture"},
            ],
            MalwareCategory.TROJAN: [
                {"id": "T1071", "name": "Application Layer Protocol"},
                {"id": "T1105", "name": "Ingress Tool Transfer"},
            ],
            MalwareCategory.BOTNET: [
                {"id": "T1583", "name": "Acquire Infrastructure"},
                {"id": "T1498", "name": "Network Denial of Service"},
            ],
        }
        
        techniques.extend(category_mapping.get(category, []))
        
        all_strings = ' '.join(strings).lower()
        
        if 'persistence' in all_strings or 'startup' in all_strings:
            techniques.append({"id": "T1547", "name": "Boot or Logon Autostart Execution"})
        
        if 'credential' in all_strings or 'password' in all_strings:
            techniques.append({"id": "T1555", "name": "Credentials from Password Stores"})
        
        return techniques
    
    def _save_to_database(self, captured: CapturedMalware, quarantine_path: str):
        """Save captured malware to database"""
        conn = sqlite3.connect(self.DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO malware_captures (
                capture_id, timestamp, source_url, source_ip, filename, file_size,
                file_type, md5_hash, sha256_hash, is_packed, packer_type,
                is_obfuscated, obfuscation_type, category, threat_level,
                yara_matches, mitre_techniques, extracted_strings, extracted_urls,
                extracted_ips, analysis_notes, quarantine_path
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            captured.capture_id,
            captured.timestamp.isoformat(),
            captured.source_url,
            captured.source_ip,
            captured.filename,
            captured.file_size,
            captured.file_type,
            captured.hashes["md5"],
            captured.hashes["sha256"],
            1 if captured.is_packed else 0,
            captured.packer_type.value,
            1 if captured.is_obfuscated else 0,
            captured.obfuscation_type.value,
            captured.category.value,
            captured.threat_level,
            json.dumps(captured.yara_matches),
            json.dumps(captured.mitre_techniques),
            json.dumps(captured.extracted_strings[:100]),
            json.dumps(captured.extracted_urls),
            json.dumps(captured.extracted_ips),
            json.dumps(captured.analysis_notes),
            quarantine_path
        ))
        
        conn.commit()
        conn.close()
    
    def get_captured_sample(self, capture_id: str) -> Optional[Dict[str, Any]]:
        """Get captured sample by ID"""
        with self._lock:
            if capture_id in self.captured_samples:
                sample = self.captured_samples[capture_id]
                return {
                    "capture_id": sample.capture_id,
                    "timestamp": sample.timestamp.isoformat(),
                    "source_url": sample.source_url,
                    "filename": sample.filename,
                    "file_size": sample.file_size,
                    "file_type": sample.file_type,
                    "hashes": sample.hashes,
                    "is_packed": sample.is_packed,
                    "packer_type": sample.packer_type.value,
                    "is_obfuscated": sample.is_obfuscated,
                    "obfuscation_type": sample.obfuscation_type.value,
                    "category": sample.category.value,
                    "threat_level": sample.threat_level,
                    "extracted_strings": sample.extracted_strings[:100],
                    "extracted_urls": sample.extracted_urls,
                    "extracted_ips": sample.extracted_ips,
                    "pe_info": sample.pe_info,
                    "yara_matches": sample.yara_matches,
                    "mitre_techniques": sample.mitre_techniques,
                    "hex_dump": sample.hex_dump,
                    "disassembly": sample.disassembly,
                    "decompiled_code": sample.decompiled_code,
                }
        
        conn = sqlite3.connect(self.DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM malware_captures WHERE capture_id = ?", (capture_id,))
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                "capture_id": row[0],
                "timestamp": row[1],
                "source_url": row[2],
                "filename": row[4],
                "file_size": row[5],
                "file_type": row[6],
                "hashes": {"md5": row[7], "sha256": row[8]},
                "is_packed": bool(row[9]),
                "packer_type": row[10],
                "is_obfuscated": bool(row[11]),
                "obfuscation_type": row[12],
                "category": row[13],
                "threat_level": row[14],
            }
        
        return None
    
    def list_captures(self, limit: int = 100) -> List[Dict[str, Any]]:
        """List all captured samples"""
        conn = sqlite3.connect(self.DB_PATH)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT capture_id, timestamp, source_url, filename, file_size,
                   category, threat_level, md5_hash
            FROM malware_captures
            ORDER BY timestamp DESC
            LIMIT ?
        """, (limit,))
        
        captures = []
        for row in cursor.fetchall():
            captures.append({
                "capture_id": row[0],
                "timestamp": row[1],
                "source_url": row[2],
                "filename": row[3],
                "file_size": row[4],
                "category": row[5],
                "threat_level": row[6],
                "md5_hash": row[7],
            })
        
        conn.close()
        return captures


_capture_engine: Optional[MalwareCaptureAnalysisEngine] = None
_engine_lock = threading.Lock()


def get_malware_capture_engine() -> MalwareCaptureAnalysisEngine:
    """Get singleton instance of malware capture engine"""
    global _capture_engine
    
    with _engine_lock:
        if _capture_engine is None:
            _capture_engine = MalwareCaptureAnalysisEngine()
        return _capture_engine
