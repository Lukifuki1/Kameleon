/**
 * {{IME_PROJEKTA}} - Authentication System
 * Domain: {{DOMENA_SL}}
 *
 * @requirement REQ-SEC-ATH-001
 * @design DSN-SEC-ATH-001
 * @test TST-SEC-ATH-001
 *
 * Sistem za avtentikacijo v varnostnem sistemu.
 * Skladen z DO-178C, IEC 61508, ISO 26262, MIL-STD-882E standardi.
 *
 * @module security/authentication
 */

import * as crypto from 'crypto';

// ============================================================================
// KRIPTOGRAFSKE KONSTANTE
// ============================================================================

const ARGON2_TIME_COST = 3;
const ARGON2_MEMORY_COST = 65536;
const ARGON2_PARALLELISM = 4;
const ARGON2_HASH_LENGTH = 32;
const ARGON2_SALT_LENGTH = 16;
const JWT_ALGORITHM = 'HS256';
const TOTP_DIGITS = 6;
const TOTP_PERIOD = 30;
const TOTP_WINDOW = 1;

// ============================================================================
// TIPI IN VMESNIKI
// ============================================================================

/**
 * Metoda avtentikacije
 */
export enum AuthenticationMethod {
    /** Uporabniško ime in geslo */
    PASSWORD = 'password',
    /** API ključ */
    API_KEY = 'api_key',
    /** JWT token */
    JWT = 'jwt',
    /** OAuth 2.0 */
    OAUTH2 = 'oauth2',
    /** Certifikat */
    CERTIFICATE = 'certificate',
    /** MFA */
    MFA = 'mfa',
    /** SAML */
    SAML = 'saml'
}

/**
 * Status avtentikacije
 */
export enum AuthenticationStatus {
    /** Uspešno */
    SUCCESS = 'success',
    /** Neuspešno */
    FAILURE = 'failure',
    /** Zahteva MFA */
    MFA_REQUIRED = 'mfa_required',
    /** Račun zaklenjen */
    ACCOUNT_LOCKED = 'account_locked',
    /** Geslo poteklo */
    PASSWORD_EXPIRED = 'password_expired',
    /** Seja potekla */
    SESSION_EXPIRED = 'session_expired',
    /** Neveljaven token */
    INVALID_TOKEN = 'invalid_token'
}

/**
 * Tip MFA
 */
export enum MfaType {
    /** TOTP */
    TOTP = 'totp',
    /** SMS */
    SMS = 'sms',
    /** Email */
    EMAIL = 'email',
    /** Hardware token */
    HARDWARE = 'hardware',
    /** Push notification */
    PUSH = 'push'
}

/**
 * Uporabnik
 */
export interface User {
    /** Unikatni identifikator */
    readonly id: string;
    /** Uporabniško ime */
    readonly username: string;
    /** Email */
    readonly email: string;
    /** Vloge */
    readonly roles: string[];
    /** Ali je MFA omogočen */
    readonly mfaEnabled: boolean;
    /** Tip MFA */
    readonly mfaType?: MfaType;
    /** Ali je račun zaklenjen */
    readonly locked: boolean;
    /** Čas zaklepa */
    readonly lockedUntil?: Date;
    /** Število neuspelih poskusov */
    readonly failedAttempts: number;
    /** Čas zadnje prijave */
    readonly lastLogin?: Date;
    /** Čas spremembe gesla */
    readonly passwordChangedAt?: Date;
    /** Metapodatki */
    readonly metadata?: Record<string, unknown>;
}

/**
 * Seja
 */
export interface Session {
    /** Unikatni identifikator */
    readonly id: string;
    /** ID uporabnika */
    readonly userId: string;
    /** Čas ustvarjanja */
    readonly createdAt: Date;
    /** Čas poteka */
    readonly expiresAt: Date;
    /** IP naslov */
    readonly ipAddress: string;
    /** User agent */
    readonly userAgent: string;
    /** Ali je aktivna */
    active: boolean;
    /** Čas zadnje aktivnosti */
    lastActivityAt: Date;
    /** Metoda avtentikacije */
    readonly authMethod: AuthenticationMethod;
    /** Ali je MFA potrjen */
    readonly mfaVerified: boolean;
}

/**
 * Rezultat avtentikacije
 */
export interface AuthenticationResult {
    /** Status */
    readonly status: AuthenticationStatus;
    /** Uporabnik (če uspešno) */
    readonly user?: User;
    /** Seja (če uspešno) */
    readonly session?: Session;
    /** Token (če uspešno) */
    readonly token?: string;
    /** Refresh token (če uspešno) */
    readonly refreshToken?: string;
    /** Sporočilo */
    readonly message?: string;
    /** Čas do odklepa (če zaklenjen) */
    readonly lockoutRemaining?: number;
}

/**
 * Zahteva za prijavo
 */
export interface LoginRequest {
    /** Uporabniško ime ali email */
    readonly identifier: string;
    /** Geslo */
    readonly password: string;
    /** MFA koda (opcijsko) */
    readonly mfaCode?: string;
    /** IP naslov */
    readonly ipAddress: string;
    /** User agent */
    readonly userAgent: string;
}

/**
 * Konfiguracija avtentikacije
 */
export interface AuthenticationConfig {
    /** Maksimalno število neuspelih poskusov */
    readonly maxFailedAttempts: number;
    /** Čas zaklepa (ms) */
    readonly lockoutDuration: number;
    /** Trajanje seje (ms) */
    readonly sessionDuration: number;
    /** Trajanje tokena (ms) */
    readonly tokenDuration: number;
    /** Trajanje refresh tokena (ms) */
    readonly refreshTokenDuration: number;
    /** Ali je MFA obvezen */
    readonly mfaRequired: boolean;
    /** Minimalna dolžina gesla */
    readonly minPasswordLength: number;
    /** Ali zahteva posebne znake */
    readonly requireSpecialChars: boolean;
    /** Ali zahteva številke */
    readonly requireNumbers: boolean;
    /** Ali zahteva velike črke */
    readonly requireUppercase: boolean;
    /** Čas veljavnosti gesla (dni) */
    readonly passwordExpiryDays: number;
    /** Število prejšnjih gesel za preverjanje */
    readonly passwordHistoryCount: number;
    /** JWT skrivnost (256-bit minimum) */
    readonly jwtSecret: string;
    /** JWT izdajatelj */
    readonly jwtIssuer: string;
    /** JWT občinstvo */
    readonly jwtAudience: string;
}

/**
 * JWT Payload
 */
interface JwtPayload {
    readonly sub: string;
    readonly iss: string;
    readonly aud: string;
    readonly iat: number;
    readonly exp: number;
    readonly jti: string;
    readonly sessionId: string;
    readonly roles: string[];
}

/**
 * JWT Header
 */
interface JwtHeader {
    readonly alg: string;
    readonly typ: string;
}

// ============================================================================
// POMOŽNE FUNKCIJE
// ============================================================================

/**
 * Generira deterministični ID seje
 */
function generateSessionId(userId: string, timestamp: number, counter: number): string {
    const combined = `session-${userId}-${timestamp}-${counter}`;
    let hash = 0;
    for (let i = 0; i < combined.length; i++) {
        const char = combined.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return `ses-${Math.abs(hash).toString(16).padStart(16, '0')}`;
}

/**
 * Generira deterministični token
 */
function generateToken(sessionId: string, timestamp: number): string {
    const combined = `token-${sessionId}-${timestamp}`;
    let hash = 0;
    for (let i = 0; i < combined.length; i++) {
        const char = combined.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return Math.abs(hash).toString(36).padStart(32, '0');
}

// ============================================================================
// GLAVNA IMPLEMENTACIJA
// ============================================================================

/**
 * Sistem za avtentikacijo
 *
 * Implementira varno avtentikacijo skladno z industrijskimi standardi.
 */
export class AuthenticationSystem {
    private readonly config: AuthenticationConfig;
    private readonly users: Map<string, User>;
    private readonly sessions: Map<string, Session>;
    private readonly passwordHashes: Map<string, string>;
    private readonly passwordHistory: Map<string, string[]>;
    private readonly mfaSecrets: Map<string, string>;
    private readonly refreshTokens: Map<string, { userId: string; sessionId: string; expiresAt: Date }>;
    private sessionCounter: number;

    constructor(config: AuthenticationConfig) {
        if (config.jwtSecret.length < 32) {
            throw new Error('JWT secret must be at least 256 bits (32 characters)');
        }
        this.config = config;
        this.users = new Map();
        this.sessions = new Map();
        this.passwordHashes = new Map();
        this.passwordHistory = new Map();
        this.mfaSecrets = new Map();
        this.refreshTokens = new Map();
        this.sessionCounter = 0;
    }

    /**
     * Prijava uporabnika
     */
    async login(request: LoginRequest): Promise<AuthenticationResult> {
        // Poišči uporabnika
        const user = this.findUserByIdentifier(request.identifier);

        if (user === undefined) {
            return {
                status: AuthenticationStatus.FAILURE,
                message: 'Invalid credentials'
            };
        }

        // Preveri ali je račun zaklenjen
        if (user.locked) {
            if (user.lockedUntil !== undefined && user.lockedUntil > new Date()) {
                const remaining = user.lockedUntil.getTime() - Date.now();
                return {
                    status: AuthenticationStatus.ACCOUNT_LOCKED,
                    message: 'Account is locked',
                    lockoutRemaining: remaining
                };
            }
            // Odkleni račun če je čas potekel
            this.unlockUser(user.id);
        }

        // Preveri geslo
        const passwordValid = await this.verifyPassword(user.id, request.password);

        if (!passwordValid) {
            this.recordFailedAttempt(user.id);
            return {
                status: AuthenticationStatus.FAILURE,
                message: 'Invalid credentials'
            };
        }

        // Preveri ali je geslo poteklo
        if (this.isPasswordExpired(user)) {
            return {
                status: AuthenticationStatus.PASSWORD_EXPIRED,
                message: 'Password has expired'
            };
        }

        // Preveri MFA
        if (user.mfaEnabled || this.config.mfaRequired) {
            if (request.mfaCode === undefined) {
                return {
                    status: AuthenticationStatus.MFA_REQUIRED,
                    message: 'MFA verification required'
                };
            }

            const mfaValid = await this.verifyMfa(user.id, request.mfaCode);
            if (!mfaValid) {
                return {
                    status: AuthenticationStatus.FAILURE,
                    message: 'Invalid MFA code'
                };
            }
        }

        // Ustvari sejo
        const session = this.createSession(user, request, true);
        const token = this.generateJwt(user, session);
        const refreshToken = this.generateRefreshToken(user.id, session.id);

        // Ponastavi neuspele poskuse
        this.resetFailedAttempts(user.id);

        // Posodobi čas zadnje prijave
        this.updateLastLogin(user.id);

        return {
            status: AuthenticationStatus.SUCCESS,
            user,
            session,
            token,
            refreshToken
        };
    }

    /**
     * Odjava uporabnika
     */
    logout(sessionId: string): boolean {
        const session = this.sessions.get(sessionId);
        if (session === undefined) {
            return false;
        }

        session.active = false;
        return true;
    }

    /**
     * Preveri token z HMAC-SHA256 verifikacijo
     */
    verifyToken(token: string): AuthenticationResult {
        const parts = token.split('.');
        if (parts.length !== 3) {
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'Invalid token format'
            };
        }

        const [headerB64, payloadB64, signatureB64] = parts;

        const expectedSignature = crypto
            .createHmac('sha256', this.config.jwtSecret)
            .update(`${headerB64}.${payloadB64}`)
            .digest('base64url');

        if (!crypto.timingSafeEqual(
            Buffer.from(signatureB64),
            Buffer.from(expectedSignature)
        )) {
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'Invalid token signature'
            };
        }

        let payload: JwtPayload;
        try {
            payload = JSON.parse(Buffer.from(payloadB64, 'base64url').toString('utf8'));
        } catch {
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'Invalid token payload'
            };
        }

        const now = Math.floor(Date.now() / 1000);
        if (payload.exp < now) {
            return {
                status: AuthenticationStatus.SESSION_EXPIRED,
                message: 'Token has expired'
            };
        }

        if (payload.iss !== this.config.jwtIssuer) {
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'Invalid token issuer'
            };
        }

        if (payload.aud !== this.config.jwtAudience) {
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'Invalid token audience'
            };
        }

        const session = this.sessions.get(payload.sessionId);
        if (session === undefined || !session.active) {
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'Session not found or inactive'
            };
        }

        const user = this.users.get(payload.sub);
        if (user === undefined) {
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'User not found'
            };
        }

        session.lastActivityAt = new Date();

        return {
            status: AuthenticationStatus.SUCCESS,
            user,
            session
        };
    }

    /**
     * Osveži token z validacijo refresh tokena
     */
    refreshToken(refreshTokenValue: string): AuthenticationResult {
        const tokenData = this.refreshTokens.get(refreshTokenValue);
        if (tokenData === undefined) {
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'Invalid refresh token'
            };
        }

        if (tokenData.expiresAt < new Date()) {
            this.refreshTokens.delete(refreshTokenValue);
            return {
                status: AuthenticationStatus.SESSION_EXPIRED,
                message: 'Refresh token has expired'
            };
        }

        const session = this.sessions.get(tokenData.sessionId);
        if (session === undefined || !session.active) {
            this.refreshTokens.delete(refreshTokenValue);
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'Session not found or inactive'
            };
        }

        const user = this.users.get(tokenData.userId);
        if (user === undefined) {
            return {
                status: AuthenticationStatus.INVALID_TOKEN,
                message: 'User not found'
            };
        }

        this.refreshTokens.delete(refreshTokenValue);

        const newToken = this.generateJwt(user, session);
        const newRefreshToken = this.generateRefreshToken(user.id, session.id);

        session.lastActivityAt = new Date();

        return {
            status: AuthenticationStatus.SUCCESS,
            user,
            session,
            token: newToken,
            refreshToken: newRefreshToken
        };
    }

    /**
     * Spremeni geslo
     */
    async changePassword(
        userId: string,
        currentPassword: string,
        newPassword: string
    ): Promise<{ success: boolean; message: string }> {
        const user = this.users.get(userId);
        if (user === undefined) {
            return { success: false, message: 'User not found' };
        }

        // Preveri trenutno geslo
        const currentValid = await this.verifyPassword(userId, currentPassword);
        if (!currentValid) {
            return { success: false, message: 'Current password is incorrect' };
        }

        // Validiraj novo geslo
        const validation = this.validatePassword(newPassword);
        if (!validation.valid) {
            return { success: false, message: validation.message };
        }

        // Preveri zgodovino gesel
        const history = this.passwordHistory.get(userId) ?? [];
        for (const oldHash of history) {
            if (await this.comparePassword(newPassword, oldHash)) {
                return { success: false, message: 'Password was used recently' };
            }
        }

        // Nastavi novo geslo
        await this.setPassword(userId, newPassword);

        return { success: true, message: 'Password changed successfully' };
    }

    /**
     * Nastavi MFA z generiranjem kriptografsko varnega TOTP secret-a (RFC 6238)
     */
    setupMfa(userId: string, type: MfaType): { secret: string; qrCode?: string; otpauthUri?: string } {
        const user = this.users.get(userId);
        if (user === undefined) {
            throw new Error('User not found');
        }

        const secretBytes = crypto.randomBytes(20);
        const secret = this.base32Encode(secretBytes);

        this.mfaSecrets.set(userId, secret);

        const updatedUser: User = {
            ...user,
            mfaEnabled: true,
            mfaType: type
        };
        this.users.set(userId, updatedUser);

        const otpauthUri = `otpauth://totp/${encodeURIComponent(this.config.jwtIssuer)}:${encodeURIComponent(user.email)}?secret=${secret}&issuer=${encodeURIComponent(this.config.jwtIssuer)}&algorithm=SHA1&digits=${TOTP_DIGITS}&period=${TOTP_PERIOD}`;

        return { secret, otpauthUri };
    }

    /**
     * Onemogoči MFA
     */
    disableMfa(userId: string): boolean {
        const user = this.users.get(userId);
        if (user === undefined) {
            return false;
        }

        this.mfaSecrets.delete(userId);

        const updatedUser: User = {
            ...user,
            mfaEnabled: false,
            mfaType: undefined
        };
        this.users.set(userId, updatedUser);

        return true;
    }

    /**
     * Pridobi aktivne seje uporabnika
     */
    getUserSessions(userId: string): Session[] {
        return Array.from(this.sessions.values())
            .filter(s => s.userId === userId && s.active);
    }

    /**
     * Prekliči sejo
     */
    revokeSession(sessionId: string): boolean {
        const session = this.sessions.get(sessionId);
        if (session === undefined) {
            return false;
        }

        session.active = false;
        return true;
    }

    /**
     * Prekliči vse seje uporabnika
     */
    revokeAllSessions(userId: string): number {
        let count = 0;
        for (const session of this.sessions.values()) {
            if (session.userId === userId && session.active) {
                session.active = false;
                count++;
            }
        }
        return count;
    }

    /**
     * Registriraj uporabnika
     */
    async registerUser(
        username: string,
        email: string,
        password: string,
        roles: string[] = ['user']
    ): Promise<{ success: boolean; user?: User; message: string }> {
        // Preveri ali uporabnik že obstaja
        if (this.findUserByIdentifier(username) !== undefined) {
            return { success: false, message: 'Username already exists' };
        }
        if (this.findUserByIdentifier(email) !== undefined) {
            return { success: false, message: 'Email already exists' };
        }

        // Validiraj geslo
        const validation = this.validatePassword(password);
        if (!validation.valid) {
            return { success: false, message: validation.message };
        }

        // Ustvari uporabnika
        const userId = generateToken(username, Date.now());
        const user: User = {
            id: userId,
            username,
            email,
            roles,
            mfaEnabled: false,
            locked: false,
            failedAttempts: 0,
            passwordChangedAt: new Date()
        };

        this.users.set(userId, user);
        await this.setPassword(userId, password);

        return { success: true, user, message: 'User registered successfully' };
    }

    // ========================================================================
    // PRIVATNE METODE
    // ========================================================================

    /**
     * Poišče uporabnika po identifikatorju
     */
    private findUserByIdentifier(identifier: string): User | undefined {
        for (const user of this.users.values()) {
            if (user.username === identifier || user.email === identifier) {
                return user;
            }
        }
        return undefined;
    }

    /**
     * Preveri geslo
     */
    private async verifyPassword(userId: string, password: string): Promise<boolean> {
        const hash = this.passwordHashes.get(userId);
        if (hash === undefined) {
            return false;
        }
        return this.comparePassword(password, hash);
    }

    /**
     * Primerja geslo s hashom z uporabo PBKDF2 (NIST SP 800-132 skladen)
     */
    private async comparePassword(password: string, storedHash: string): Promise<boolean> {
        const parts = storedHash.split('$');
        if (parts.length !== 4) {
            return false;
        }

        const [algorithm, iterations, salt, hash] = parts;
        if (algorithm !== 'pbkdf2-sha512') {
            return false;
        }

        const iterationCount = parseInt(iterations, 10);
        const saltBuffer = Buffer.from(salt, 'hex');

        return new Promise((resolve, reject) => {
            crypto.pbkdf2(password, saltBuffer, iterationCount, ARGON2_HASH_LENGTH, 'sha512', (err, derivedKey) => {
                if (err) {
                    reject(err);
                    return;
                }
                const computedHash = derivedKey.toString('hex');
                resolve(crypto.timingSafeEqual(Buffer.from(hash, 'hex'), Buffer.from(computedHash, 'hex')));
            });
        });
    }

    /**
     * Hashira geslo z uporabo PBKDF2 (NIST SP 800-132 skladen)
     * Uporablja 600.000 iteracij SHA-512 za odpornost proti brute-force napadom
     */
    private async hashPassword(password: string): Promise<string> {
        const salt = crypto.randomBytes(ARGON2_SALT_LENGTH);
        const iterations = 600000;

        return new Promise((resolve, reject) => {
            crypto.pbkdf2(password, salt, iterations, ARGON2_HASH_LENGTH, 'sha512', (err, derivedKey) => {
                if (err) {
                    reject(err);
                    return;
                }
                const hash = derivedKey.toString('hex');
                resolve(`pbkdf2-sha512$${iterations}$${salt.toString('hex')}$${hash}`);
            });
        });
    }

    /**
     * Nastavi geslo
     */
    private async setPassword(userId: string, password: string): Promise<void> {
        const hash = await this.hashPassword(password);

        const history = this.passwordHistory.get(userId) ?? [];
        history.unshift(hash);
        if (history.length > this.config.passwordHistoryCount) {
            history.pop();
        }
        this.passwordHistory.set(userId, history);

        this.passwordHashes.set(userId, hash);

        const user = this.users.get(userId);
        if (user !== undefined) {
            const updatedUser: User = {
                ...user,
                passwordChangedAt: new Date()
            };
            this.users.set(userId, updatedUser);
        }
    }

    /**
     * Preveri ali je geslo poteklo
     */
    private isPasswordExpired(user: User): boolean {
        if (user.passwordChangedAt === undefined) {
            return true;
        }

        const expiryDate = new Date(user.passwordChangedAt);
        expiryDate.setDate(expiryDate.getDate() + this.config.passwordExpiryDays);

        return new Date() > expiryDate;
    }

    /**
     * Validiraj geslo
     */
    private validatePassword(password: string): { valid: boolean; message: string } {
        if (password.length < this.config.minPasswordLength) {
            return { valid: false, message: `Password must be at least ${this.config.minPasswordLength} characters` };
        }

        if (this.config.requireUppercase && !/[A-Z]/.test(password)) {
            return { valid: false, message: 'Password must contain uppercase letters' };
        }

        if (this.config.requireNumbers && !/[0-9]/.test(password)) {
            return { valid: false, message: 'Password must contain numbers' };
        }

        if (this.config.requireSpecialChars && !/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
            return { valid: false, message: 'Password must contain special characters' };
        }

        return { valid: true, message: 'Password is valid' };
    }

    /**
     * Preveri MFA z TOTP verifikacijo (RFC 6238)
     */
    private async verifyMfa(userId: string, code: string): Promise<boolean> {
        if (code.length !== TOTP_DIGITS || !/^\d+$/.test(code)) {
            return false;
        }

        const secret = this.mfaSecrets.get(userId);
        if (secret === undefined) {
            return false;
        }

        const now = Math.floor(Date.now() / 1000);
        const timeStep = Math.floor(now / TOTP_PERIOD);

        for (let i = -TOTP_WINDOW; i <= TOTP_WINDOW; i++) {
            const expectedCode = this.generateTotp(secret, timeStep + i);
            if (crypto.timingSafeEqual(Buffer.from(code), Buffer.from(expectedCode))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Generira TOTP kodo (RFC 6238)
     */
    private generateTotp(secret: string, timeStep: number): string {
        const secretBytes = this.base32Decode(secret);
        const timeBuffer = Buffer.alloc(8);
        timeBuffer.writeBigUInt64BE(BigInt(timeStep));

        const hmac = crypto.createHmac('sha1', secretBytes);
        hmac.update(timeBuffer);
        const hash = hmac.digest();

        const offset = hash[hash.length - 1] & 0x0f;
        const binary =
            ((hash[offset] & 0x7f) << 24) |
            ((hash[offset + 1] & 0xff) << 16) |
            ((hash[offset + 2] & 0xff) << 8) |
            (hash[offset + 3] & 0xff);

        const otp = binary % Math.pow(10, TOTP_DIGITS);
        return otp.toString().padStart(TOTP_DIGITS, '0');
    }

    /**
     * Base32 kodiranje (RFC 4648)
     */
    private base32Encode(buffer: Buffer): string {
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
        let result = '';
        let bits = 0;
        let value = 0;

        for (const byte of buffer) {
            value = (value << 8) | byte;
            bits += 8;

            while (bits >= 5) {
                result += alphabet[(value >>> (bits - 5)) & 0x1f];
                bits -= 5;
            }
        }

        if (bits > 0) {
            result += alphabet[(value << (5 - bits)) & 0x1f];
        }

        return result;
    }

    /**
     * Base32 dekodiranje (RFC 4648)
     */
    private base32Decode(encoded: string): Buffer {
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
        const cleanedInput = encoded.toUpperCase().replace(/=+$/, '');

        let bits = 0;
        let value = 0;
        const output: number[] = [];

        for (const char of cleanedInput) {
            const index = alphabet.indexOf(char);
            if (index === -1) {
                throw new Error('Invalid base32 character');
            }

            value = (value << 5) | index;
            bits += 5;

            if (bits >= 8) {
                output.push((value >>> (bits - 8)) & 0xff);
                bits -= 8;
            }
        }

        return Buffer.from(output);
    }

    /**
     * Generira JWT token z HMAC-SHA256 podpisom
     */
    private generateJwt(user: User, session: Session): string {
        const header: JwtHeader = {
            alg: JWT_ALGORITHM,
            typ: 'JWT'
        };

        const now = Math.floor(Date.now() / 1000);
        const payload: JwtPayload = {
            sub: user.id,
            iss: this.config.jwtIssuer,
            aud: this.config.jwtAudience,
            iat: now,
            exp: now + Math.floor(this.config.tokenDuration / 1000),
            jti: crypto.randomBytes(16).toString('hex'),
            sessionId: session.id,
            roles: user.roles
        };

        const headerB64 = Buffer.from(JSON.stringify(header)).toString('base64url');
        const payloadB64 = Buffer.from(JSON.stringify(payload)).toString('base64url');

        const signature = crypto
            .createHmac('sha256', this.config.jwtSecret)
            .update(`${headerB64}.${payloadB64}`)
            .digest('base64url');

        return `${headerB64}.${payloadB64}.${signature}`;
    }

    /**
     * Generira refresh token
     */
    private generateRefreshToken(userId: string, sessionId: string): string {
        const token = crypto.randomBytes(32).toString('hex');
        const expiresAt = new Date(Date.now() + this.config.refreshTokenDuration);

        this.refreshTokens.set(token, {
            userId,
            sessionId,
            expiresAt
        });

        return token;
    }

    /**
     * Ustvari sejo
     */
    private createSession(
        user: User,
        request: LoginRequest,
        mfaVerified: boolean
    ): Session {
        this.sessionCounter++;
        const now = new Date();
        const expiresAt = new Date(now.getTime() + this.config.sessionDuration);

        const session: Session = {
            id: generateSessionId(user.id, now.getTime(), this.sessionCounter),
            userId: user.id,
            createdAt: now,
            expiresAt,
            ipAddress: request.ipAddress,
            userAgent: request.userAgent,
            active: true,
            lastActivityAt: now,
            authMethod: AuthenticationMethod.PASSWORD,
            mfaVerified
        };

        this.sessions.set(session.id, session);
        return session;
    }

    /**
     * Zabeleži neuspel poskus
     */
    private recordFailedAttempt(userId: string): void {
        const user = this.users.get(userId);
        if (user === undefined) {
            return;
        }

        const failedAttempts = user.failedAttempts + 1;
        let locked = user.locked;
        let lockedUntil = user.lockedUntil;

        if (failedAttempts >= this.config.maxFailedAttempts) {
            locked = true;
            lockedUntil = new Date(Date.now() + this.config.lockoutDuration);
        }

        const updatedUser: User = {
            ...user,
            failedAttempts,
            locked,
            lockedUntil
        };
        this.users.set(userId, updatedUser);
    }

    /**
     * Ponastavi neuspele poskuse
     */
    private resetFailedAttempts(userId: string): void {
        const user = this.users.get(userId);
        if (user === undefined) {
            return;
        }

        const updatedUser: User = {
            ...user,
            failedAttempts: 0
        };
        this.users.set(userId, updatedUser);
    }

    /**
     * Odkleni uporabnika
     */
    private unlockUser(userId: string): void {
        const user = this.users.get(userId);
        if (user === undefined) {
            return;
        }

        const updatedUser: User = {
            ...user,
            locked: false,
            lockedUntil: undefined,
            failedAttempts: 0
        };
        this.users.set(userId, updatedUser);
    }

    /**
     * Posodobi čas zadnje prijave
     */
    private updateLastLogin(userId: string): void {
        const user = this.users.get(userId);
        if (user === undefined) {
            return;
        }

        const updatedUser: User = {
            ...user,
            lastLogin: new Date()
        };
        this.users.set(userId, updatedUser);
    }
}

// ============================================================================
// TOVARNIŠKA FUNKCIJA
// ============================================================================

/**
 * Ustvari sistem za avtentikacijo
 */
export function createAuthenticationSystem(
tvojih popravkov postati 100%     config: {
        jwtSecret: string;
        jwtIssuer: string;
        jwtAudience: string;
    } & Partial<Omit<AuthenticationConfig, 'jwtSecret' | 'jwtIssuer' | 'jwtAudience'>>
): AuthenticationSystem {
    if (!config.jwtSecret || config.jwtSecret.length < 32) {
        throw new Error('JWT secret is required and must be at least 256 bits (32 characters)');
    }
    if (!config.jwtIssuer) {
        throw new Error('JWT issuer is required');
    }
    if (!config.jwtAudience) {
        throw new Error('JWT audience is required');
    }

    const defaultConfig: AuthenticationConfig = {
        maxFailedAttempts: 5,
        lockoutDuration: 900000,
        sessionDuration: 28800000,
        tokenDuration: 3600000,
        refreshTokenDuration: 604800000,
        mfaRequired: false,
        minPasswordLength: 12,
        requireSpecialChars: true,
        requireNumbers: true,
        requireUppercase: true,
        passwordExpiryDays: 90,
        passwordHistoryCount: 12,
        jwtSecret: config.jwtSecret,
        jwtIssuer: config.jwtIssuer,
        jwtAudience: config.jwtAudience
    };

    return new AuthenticationSystem({
        ...defaultConfig,
        ...config
    });
}

// ============================================================================
// IZVOZ
// ============================================================================

export default AuthenticationSystem;
