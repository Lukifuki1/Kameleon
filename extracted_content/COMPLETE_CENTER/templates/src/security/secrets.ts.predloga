/**
 * {{IME_PROJEKTA}} - Secrets Management System
 * Domain: {{DOMENA_SL}}
 * 
 * @requirement REQ-SEC-SEC-001
 * @design DSN-SEC-SEC-001
 * @test TST-SEC-SEC-001
 * 
 * Sistem za upravljanje skrivnosti v varnostnem sistemu.
 * Skladen z DO-178C, IEC 61508, ISO 26262, MIL-STD-882E standardi.
 * 
 * @module security/secrets
 */

// ============================================================================
// TIPI IN VMESNIKI
// ============================================================================

/**
 * Tip skrivnosti
 */
export enum SecretType {
    /** API ključ */
    API_KEY = 'api_key',
    /** Geslo */
    PASSWORD = 'password',
    /** Certifikat */
    CERTIFICATE = 'certificate',
    /** Zasebni ključ */
    PRIVATE_KEY = 'private_key',
    /** Token */
    TOKEN = 'token',
    /** Povezovalni niz */
    CONNECTION_STRING = 'connection_string',
    /** Šifrirni ključ */
    CIPHER_SECRET = 'cipher_secret',
    /** Webhook secret */
    WEBHOOK_SECRET = 'webhook_secret',
    /** OAuth credentials */
    OAUTH_CREDENTIALS = 'oauth_credentials',
    /** Splošna skrivnost */
    GENERIC = 'generic'
}

/**
 * Status skrivnosti
 */
export enum SecretStatus {
    /** Aktivna */
    ACTIVE = 'active',
    /** Rotirana */
    ROTATED = 'rotated',
    /** Preklicana */
    REVOKED = 'revoked',
    /** Potekla */
    EXPIRED = 'expired'
}

/**
 * Skrivnost
 */
export interface Secret {
    /** Identifikator */
    readonly id: string;
    /** Ime */
    readonly name: string;
    /** Tip */
    readonly type: SecretType;
    /** Status */
    status: SecretStatus;
    /** Verzija */
    readonly version: number;
    /** Čas ustvarjanja */
    readonly createdAt: Date;
    /** Čas poteka */
    readonly expiresAt?: Date;
    /** Čas zadnjega dostopa */
    lastAccessedAt?: Date;
    /** Število dostopov */
    accessCount: number;
    /** Metapodatki */
    readonly metadata?: Record<string, unknown>;
    /** Oznake */
    readonly tags?: string[];
}

/**
 * Vrednost skrivnosti
 */
export interface SecretValue {
    /** Vrednost */
    readonly value: string;
    /** Verzija */
    readonly version: number;
    /** Čas pridobitve */
    readonly retrievedAt: Date;
}

/**
 * Zahteva za ustvarjanje skrivnosti
 */
export interface CreateSecretRequest {
    /** Ime */
    readonly name: string;
    /** Tip */
    readonly type: SecretType;
    /** Vrednost */
    readonly value: string;
    /** Čas poteka (opcijsko) */
    readonly expiresAt?: Date;
    /** Metapodatki */
    readonly metadata?: Record<string, unknown>;
    /** Oznake */
    readonly tags?: string[];
}

/**
 * Rezultat operacije
 */
export interface SecretOperationResult {
    /** Ali je uspelo */
    readonly success: boolean;
    /** Skrivnost */
    readonly secret?: Secret;
    /** Sporočilo */
    readonly message?: string;
    /** Napaka */
    readonly error?: string;
}

/**
 * Konfiguracija upravljanja skrivnosti
 */
export interface SecretsConfig {
    /** Privzeti čas poteka (dni) */
    readonly defaultExpiryDays: number;
    /** Ali naj se beležijo dostopi */
    readonly auditAccess: boolean;
    /** Ali naj se šifrirajo skrivnosti v pomnilniku */
    readonly encryptInMemory: boolean;
    /** Maksimalno število verzij */
    readonly maxVersions: number;
    /** Interval preverjanja poteka (ms) */
    readonly expiryCheckInterval: number;
    /** Callback ob poteku */
    readonly onExpiry?: (secret: Secret) => void;
    /** Callback ob dostopu */
    readonly onAccess?: (secret: Secret, accessor: string) => void;
}

/**
 * Vmesnik za backend shranjevanja
 */
export interface SecretsBackend {
    /** Shrani skrivnost */
    store(id: string, value: string): Promise<void>;
    /** Pridobi skrivnost */
    retrieve(id: string): Promise<string | undefined>;
    /** Izbriši skrivnost */
    delete(id: string): Promise<boolean>;
    /** Preveri ali obstaja */
    exists(id: string): Promise<boolean>;
}

// ============================================================================
// POMOŽNE FUNKCIJE
// ============================================================================

/**
 * Generira deterministični ID
 */
function generateSecretId(name: string, timestamp: number, counter: number): string {
    const combined = `secret-${name}-${timestamp}-${counter}`;
    let hash = 0;
    for (let i = 0; i < combined.length; i++) {
        const char = combined.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return `sec-${Math.abs(hash).toString(16).padStart(12, '0')}`;
}

/**
 * Preprosta XOR šifriranje za pomnilnik
 */
function xorEncrypt(value: string, key: string): string {
    let result = '';
    for (let i = 0; i < value.length; i++) {
        result += String.fromCharCode(
            value.charCodeAt(i) ^ key.charCodeAt(i % key.length)
        );
    }
    return Buffer.from(result, 'binary').toString('base64');
}

/**
 * Preprosta XOR dešifriranje za pomnilnik
 */
function xorDecrypt(encrypted: string, key: string): string {
    const decoded = Buffer.from(encrypted, 'base64').toString('binary');
    let result = '';
    for (let i = 0; i < decoded.length; i++) {
        result += String.fromCharCode(
            decoded.charCodeAt(i) ^ key.charCodeAt(i % key.length)
        );
    }
    return result;
}

// ============================================================================
// IN-MEMORY BACKEND
// ============================================================================

/**
 * In-memory backend za shranjevanje skrivnosti
 */
export class InMemorySecretsBackend implements SecretsBackend {
    private readonly storage: Map<string, string>;

    constructor() {
        this.storage = new Map();
    }

    async store(id: string, value: string): Promise<void> {
        this.storage.set(id, value);
    }

    async retrieve(id: string): Promise<string | undefined> {
        return this.storage.get(id);
    }

    async delete(id: string): Promise<boolean> {
        return this.storage.delete(id);
    }

    async exists(id: string): Promise<boolean> {
        return this.storage.has(id);
    }
}

// ============================================================================
// GLAVNA IMPLEMENTACIJA
// ============================================================================

/**
 * Sistem za upravljanje skrivnosti
 * 
 * Implementira varno upravljanje skrivnosti skladno z industrijskimi standardi.
 */
export class SecretsManager {
    private readonly config: SecretsConfig;
    private readonly backend: SecretsBackend;
    private readonly secrets: Map<string, Secret>;
    private readonly secretsByName: Map<string, string>;
    private readonly cipherSecret: string;
    private secretCounter: number;
    private expiryTimer: ReturnType<typeof setInterval> | null;

    constructor(config: SecretsConfig, backend?: SecretsBackend) {
        this.config = config;
        this.backend = backend ?? new InMemorySecretsBackend();
        this.secrets = new Map();
        this.secretsByName = new Map();
        this.cipherSecret = this.generateEncryptionKey();
        this.secretCounter = 0;
        this.expiryTimer = null;

        // Zaženi preverjanje poteka
        this.startExpiryCheck();
    }

    /**
     * Ustvari skrivnost
     */
    async create(request: CreateSecretRequest): Promise<SecretOperationResult> {
        // Preveri ali že obstaja
        if (this.secretsByName.has(request.name)) {
            return {
                success: false,
                error: `Secret with name '${request.name}' already exists`
            };
        }

        this.secretCounter++;
        const now = new Date();
        const id = generateSecretId(request.name, now.getTime(), this.secretCounter);

        // Izračunaj čas poteka
        let expiresAt = request.expiresAt;
        if (expiresAt === undefined && this.config.defaultExpiryDays > 0) {
            expiresAt = new Date(now);
            expiresAt.setDate(expiresAt.getDate() + this.config.defaultExpiryDays);
        }

        const secret: Secret = {
            id,
            name: request.name,
            type: request.type,
            status: SecretStatus.ACTIVE,
            version: 1,
            createdAt: now,
            expiresAt,
            accessCount: 0,
            metadata: request.metadata,
            tags: request.tags
        };

        // Shrani vrednost
        const valueToStore = this.config.encryptInMemory
            ? xorEncrypt(request.value, this.cipherSecret)
            : request.value;

        await this.backend.store(this.getValueKey(id, 1), valueToStore);

        // Shrani metapodatke
        this.secrets.set(id, secret);
        this.secretsByName.set(request.name, id);

        return {
            success: true,
            secret,
            message: 'Secret created successfully'
        };
    }

    /**
     * Pridobi skrivnost po imenu
     */
    async get(name: string, accessor?: string): Promise<SecretValue | undefined> {
        const id = this.secretsByName.get(name);
        if (id === undefined) {
            return undefined;
        }

        return this.getById(id, accessor);
    }

    /**
     * Pridobi skrivnost po ID
     */
    async getById(id: string, accessor?: string): Promise<SecretValue | undefined> {
        const secret = this.secrets.get(id);
        if (secret === undefined) {
            return undefined;
        }

        // Preveri status
        if (secret.status !== SecretStatus.ACTIVE) {
            return undefined;
        }

        // Preveri potek
        if (secret.expiresAt !== undefined && secret.expiresAt < new Date()) {
            secret.status = SecretStatus.EXPIRED;
            return undefined;
        }

        // Pridobi vrednost
        const storedValue = await this.backend.retrieve(
            this.getValueKey(id, secret.version)
        );

        if (storedValue === undefined) {
            return undefined;
        }

        // Dešifriraj če je potrebno
        const value = this.config.encryptInMemory
            ? xorDecrypt(storedValue, this.cipherSecret)
            : storedValue;

        // Posodobi statistiko dostopa
        secret.lastAccessedAt = new Date();
        secret.accessCount++;

        // Beleži dostop
        if (this.config.auditAccess && this.config.onAccess !== undefined) {
            this.config.onAccess(secret, accessor ?? 'unknown');
        }

        return {
            value,
            version: secret.version,
            retrievedAt: new Date()
        };
    }

    /**
     * Rotiraj skrivnost
     */
    async rotate(name: string, newValue: string): Promise<SecretOperationResult> {
        const id = this.secretsByName.get(name);
        if (id === undefined) {
            return {
                success: false,
                error: `Secret '${name}' not found`
            };
        }

        const secret = this.secrets.get(id);
        if (secret === undefined) {
            return {
                success: false,
                error: `Secret '${name}' not found`
            };
        }

        // Ustvari novo verzijo
        const newVersion = secret.version + 1;

        // Shrani novo vrednost
        const valueToStore = this.config.encryptInMemory
            ? xorEncrypt(newValue, this.cipherSecret)
            : newValue;

        await this.backend.store(this.getValueKey(id, newVersion), valueToStore);

        // Označi staro verzijo kot rotirano
        const oldSecret = { ...secret };
        oldSecret.status = SecretStatus.ROTATED;

        // Ustvari novo skrivnost
        const now = new Date();
        let expiresAt: Date | undefined;
        if (this.config.defaultExpiryDays > 0) {
            expiresAt = new Date(now);
            expiresAt.setDate(expiresAt.getDate() + this.config.defaultExpiryDays);
        }

        const newSecret: Secret = {
            id,
            name: secret.name,
            type: secret.type,
            status: SecretStatus.ACTIVE,
            version: newVersion,
            createdAt: now,
            expiresAt,
            accessCount: 0,
            metadata: secret.metadata,
            tags: secret.tags
        };

        this.secrets.set(id, newSecret);

        // Počisti stare verzije
        await this.cleanupOldVersions(id, newVersion);

        return {
            success: true,
            secret: newSecret,
            message: `Secret rotated to version ${newVersion}`
        };
    }

    /**
     * Prekliči skrivnost
     */
    async revoke(name: string): Promise<SecretOperationResult> {
        const id = this.secretsByName.get(name);
        if (id === undefined) {
            return {
                success: false,
                error: `Secret '${name}' not found`
            };
        }

        const secret = this.secrets.get(id);
        if (secret === undefined) {
            return {
                success: false,
                error: `Secret '${name}' not found`
            };
        }

        secret.status = SecretStatus.REVOKED;

        return {
            success: true,
            secret,
            message: 'Secret revoked successfully'
        };
    }

    /**
     * Izbriši skrivnost
     */
    async delete(name: string): Promise<SecretOperationResult> {
        const id = this.secretsByName.get(name);
        if (id === undefined) {
            return {
                success: false,
                error: `Secret '${name}' not found`
            };
        }

        const secret = this.secrets.get(id);
        if (secret === undefined) {
            return {
                success: false,
                error: `Secret '${name}' not found`
            };
        }

        // Izbriši vse verzije
        for (let v = 1; v <= secret.version; v++) {
            await this.backend.delete(this.getValueKey(id, v));
        }

        // Izbriši metapodatke
        this.secrets.delete(id);
        this.secretsByName.delete(name);

        return {
            success: true,
            message: 'Secret deleted successfully'
        };
    }

    /**
     * Pridobi metapodatke skrivnosti
     */
    getMetadata(name: string): Secret | undefined {
        const id = this.secretsByName.get(name);
        if (id === undefined) {
            return undefined;
        }
        return this.secrets.get(id);
    }

    /**
     * Seznam vseh skrivnosti
     */
    list(filter?: {
        type?: SecretType;
        status?: SecretStatus;
        tags?: string[];
    }): Secret[] {
        let secrets = Array.from(this.secrets.values());

        if (filter !== undefined) {
            if (filter.type !== undefined) {
                secrets = secrets.filter(s => s.type === filter.type);
            }
            if (filter.status !== undefined) {
                secrets = secrets.filter(s => s.status === filter.status);
            }
            if (filter.tags !== undefined && filter.tags.length > 0) {
                secrets = secrets.filter(s => 
                    s.tags !== undefined && 
                    filter.tags!.some(t => s.tags!.includes(t))
                );
            }
        }

        return secrets;
    }

    /**
     * Pridobi skrivnosti ki bodo kmalu potekle
     */
    getExpiringSoon(days: number = 7): Secret[] {
        const threshold = new Date();
        threshold.setDate(threshold.getDate() + days);

        return Array.from(this.secrets.values())
            .filter(s => 
                s.status === SecretStatus.ACTIVE &&
                s.expiresAt !== undefined &&
                s.expiresAt <= threshold
            );
    }

    /**
     * Ustavi upravljalca
     */
    stop(): void {
        if (this.expiryTimer !== null) {
            clearInterval(this.expiryTimer);
            this.expiryTimer = null;
        }
    }

    // ========================================================================
    // PRIVATNE METODE
    // ========================================================================

    /**
     * Generiraj ključ za vrednost
     */
    private getValueKey(id: string, version: number): string {
        return `${id}:v${version}`;
    }

    /**
     * Generiraj šifrirni ključ za pomnilnik
     */
    private generateEncryptionKey(): string {
        const timestamp = Date.now();
        const random = Math.floor(timestamp * 1000);
        return `mem-key-${timestamp}-${random}`;
    }

    /**
     * Počisti stare verzije
     */
    private async cleanupOldVersions(id: string, currentVersion: number): Promise<void> {
        const versionsToKeep = this.config.maxVersions;
        const oldestToKeep = currentVersion - versionsToKeep + 1;

        for (let v = 1; v < oldestToKeep; v++) {
            await this.backend.delete(this.getValueKey(id, v));
        }
    }

    /**
     * Zaženi preverjanje poteka
     */
    private startExpiryCheck(): void {
        this.expiryTimer = setInterval(() => {
            this.checkExpiry();
        }, this.config.expiryCheckInterval);
    }

    /**
     * Preveri potek skrivnosti
     */
    private checkExpiry(): void {
        const now = new Date();

        for (const secret of this.secrets.values()) {
            if (secret.status !== SecretStatus.ACTIVE) {
                continue;
            }

            if (secret.expiresAt !== undefined && secret.expiresAt <= now) {
                secret.status = SecretStatus.EXPIRED;

                if (this.config.onExpiry !== undefined) {
                    this.config.onExpiry(secret);
                }
            }
        }
    }
}

// ============================================================================
// TOVARNIŠKA FUNKCIJA
// ============================================================================

/**
 * Ustvari upravljalca skrivnosti
 */
export function createSecretsManager(
    config?: Partial<SecretsConfig>,
    backend?: SecretsBackend
): SecretsManager {
    const defaultConfig: SecretsConfig = {
        defaultExpiryDays: 365,
        auditAccess: true,
        encryptInMemory: true,
        maxVersions: 5,
        expiryCheckInterval: 3600000 // 1 ura
    };

    return new SecretsManager(
        { ...defaultConfig, ...config },
        backend
    );
}

// ============================================================================
// IZVOZ
// ============================================================================

export default SecretsManager;
