"""
GLOBAL INTELLIGENCE SECURITY COMMAND CENTER - MALWARE ANALYSIS MODULE
Complete implementation of malware-analysis.ts.predloga

This module implements:
- Static Analysis (PE parsing, string extraction, entropy, imports/exports)
- Dynamic Analysis (sandbox execution, behavior monitoring)
- Behavioral Analysis (API calls, file operations, network activity)
- YARA Matching
- Malware Family Attribution
- Packer/Crypter Detection
- Obfuscation Analysis
- IOC Extraction

Classification: TOP SECRET // NSOC // TIER-0
"""

import hashlib
import struct
import time
import json
import base64
import secrets
import re
import os
import math
import logging
from datetime import datetime
from typing import List, Dict, Any, Optional, Set, Tuple
from dataclasses import dataclass, field, asdict
from enum import Enum

logger = logging.getLogger(__name__)


class MalwareType(str, Enum):
    TROJAN = "TROJAN"
    RANSOMWARE = "RANSOMWARE"
    WORM = "WORM"
    VIRUS = "VIRUS"
    ROOTKIT = "ROOTKIT"
    BOOTKIT = "BOOTKIT"
    BACKDOOR = "BACKDOOR"
    RAT = "RAT"
    KEYLOGGER = "KEYLOGGER"
    SPYWARE = "SPYWARE"
    ADWARE = "ADWARE"
    CRYPTOMINER = "CRYPTOMINER"
    BOTNET = "BOTNET"
    DROPPER = "DROPPER"
    DOWNLOADER = "DOWNLOADER"
    LOADER = "LOADER"
    INFOSTEALER = "INFOSTEALER"
    BANKER = "BANKER"
    WEBSHELL = "WEBSHELL"
    EXPLOIT_KIT = "EXPLOIT_KIT"
    APT_IMPLANT = "APT_IMPLANT"
    UNKNOWN = "UNKNOWN"


class AnalysisType(str, Enum):
    STATIC = "STATIC"
    DYNAMIC = "DYNAMIC"
    BEHAVIORAL = "BEHAVIORAL"
    MEMORY = "MEMORY"
    NETWORK = "NETWORK"
    HYBRID = "HYBRID"


class FileType(str, Enum):
    PE_EXE = "PE_EXE"
    PE_DLL = "PE_DLL"
    PE_SYS = "PE_SYS"
    ELF = "ELF"
    MACHO = "MACHO"
    SCRIPT = "SCRIPT"
    DOCUMENT = "DOCUMENT"
    ARCHIVE = "ARCHIVE"
    PDF = "PDF"
    OFFICE = "OFFICE"
    JAR = "JAR"
    APK = "APK"
    SHELLCODE = "SHELLCODE"
    UNKNOWN = "UNKNOWN"


class ThreatLevel(str, Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    CLEAN = "CLEAN"
    UNKNOWN = "UNKNOWN"


class SandboxType(str, Enum):
    WINDOWS_7 = "WINDOWS_7"
    WINDOWS_10 = "WINDOWS_10"
    WINDOWS_11 = "WINDOWS_11"
    LINUX = "LINUX"
    MACOS = "MACOS"
    ANDROID = "ANDROID"
    IOS = "IOS"


class EvasionTechnique(str, Enum):
    ANTI_VM = "ANTI_VM"
    ANTI_DEBUG = "ANTI_DEBUG"
    ANTI_SANDBOX = "ANTI_SANDBOX"
    ANTI_ANALYSIS = "ANTI_ANALYSIS"
    TIMING_BASED = "TIMING_BASED"
    USER_INTERACTION = "USER_INTERACTION"
    ENVIRONMENT_CHECK = "ENVIRONMENT_CHECK"
    PROCESS_CHECK = "PROCESS_CHECK"
    REGISTRY_CHECK = "REGISTRY_CHECK"
    FILE_CHECK = "FILE_CHECK"
    NETWORK_CHECK = "NETWORK_CHECK"


class PackerType(str, Enum):
    UPX = "UPX"
    ASPACK = "ASPACK"
    PETITE = "PETITE"
    MPRESS = "MPRESS"
    THEMIDA = "THEMIDA"
    VMPROTECT = "VMPROTECT"
    ENIGMA = "ENIGMA"
    ARMADILLO = "ARMADILLO"
    OBSIDIUM = "OBSIDIUM"
    CUSTOM = "CUSTOM"
    NONE = "NONE"


class ObfuscationType(str, Enum):
    STRING_ENCRYPTION = "STRING_ENCRYPTION"
    CONTROL_FLOW = "CONTROL_FLOW"
    DEAD_CODE = "DEAD_CODE"
    OPAQUE_PREDICATES = "OPAQUE_PREDICATES"
    CODE_VIRTUALIZATION = "CODE_VIRTUALIZATION"
    METAMORPHIC = "METAMORPHIC"
    POLYMORPHIC = "POLYMORPHIC"
    API_HASHING = "API_HASHING"
    IMPORT_HIDING = "IMPORT_HIDING"


@dataclass
class FileHashes:
    md5: str
    sha1: str
    sha256: str
    sha512: str
    ssdeep: Optional[str]
    imphash: Optional[str]
    tlsh: Optional[str]


@dataclass
class PEHeader:
    machine: str
    timestamp: str
    characteristics: List[str]
    subsystem: str
    dll_characteristics: List[str]
    entry_point: int
    image_base: int
    section_alignment: int
    file_alignment: int
    size_of_image: int
    size_of_headers: int
    checksum: int


@dataclass
class PESection:
    name: str
    virtual_address: int
    virtual_size: int
    raw_size: int
    entropy: float
    characteristics: List[str]
    md5: str


@dataclass
class ImportedFunction:
    dll: str
    function: str
    ordinal: Optional[int]


@dataclass
class ExportedFunction:
    name: str
    ordinal: int
    address: int


@dataclass
class StaticAnalysisResult:
    file_type: FileType
    file_size: int
    hashes: FileHashes
    pe_header: Optional[PEHeader]
    sections: List[PESection]
    imports: List[ImportedFunction]
    exports: List[ExportedFunction]
    strings: List[str]
    suspicious_strings: List[Dict[str, str]]
    entropy: float
    packer: Optional[PackerType]
    obfuscation: List[ObfuscationType]
    resources: List[Dict[str, Any]]
    certificates: List[Dict[str, Any]]
    version_info: Dict[str, str]


@dataclass
class DynamicAnalysisResult:
    sandbox: SandboxType
    duration: int
    processes_created: List[Dict[str, Any]]
    files_created: List[str]
    files_modified: List[str]
    files_deleted: List[str]
    registry_created: List[str]
    registry_modified: List[str]
    registry_deleted: List[str]
    network_connections: List[Dict[str, Any]]
    dns_queries: List[str]
    http_requests: List[Dict[str, Any]]
    mutexes_created: List[str]
    api_calls: List[Dict[str, Any]]
    screenshots: List[str]
    memory_dumps: List[str]
    dropped_files: List[Dict[str, Any]]


@dataclass
class BehavioralIndicator:
    category: str
    description: str
    severity: ThreatLevel
    mitre_technique: Optional[str]
    evidence: List[str]


@dataclass
class MalwareAnalysisReport:
    analysis_id: str
    file_name: str
    file_type: FileType
    threat_level: ThreatLevel
    malware_type: Optional[MalwareType]
    malware_family: Optional[str]
    static_analysis: StaticAnalysisResult
    dynamic_analysis: Optional[DynamicAnalysisResult]
    behavioral_indicators: List[BehavioralIndicator]
    yara_matches: List[Dict[str, Any]]
    iocs: List[Dict[str, str]]
    evasion_techniques: List[EvasionTechnique]
    mitre_techniques: List[str]
    recommendations: List[str]
    timestamp: str


class StaticAnalyzer:
    """Static malware analysis engine"""
    
    def __init__(self):
        self.suspicious_api_patterns = [
            "VirtualAlloc", "VirtualProtect", "WriteProcessMemory", "CreateRemoteThread",
            "NtUnmapViewOfSection", "SetThreadContext", "ResumeThread", "LoadLibrary",
            "GetProcAddress", "CreateProcess", "ShellExecute", "WinExec", "URLDownloadToFile",
            "InternetOpen", "InternetConnect", "HttpOpenRequest", "HttpSendRequest",
            "RegSetValue", "RegCreateKey", "CreateService", "StartService",
            "CryptEncrypt", "CryptDecrypt", "CryptAcquireContext", "CryptGenKey",
            "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtQueryInformationProcess",
            "GetTickCount", "QueryPerformanceCounter", "Sleep", "SetWindowsHookEx",
            "GetAsyncKeyState", "GetKeyState", "GetClipboardData", "OpenClipboard"
        ]
        
        self.suspicious_string_patterns = [
            (r'https?://[^\s<>"{}|\\^`\[\]]+', "URL"),
            (r'\b(?:\d{1,3}\.){3}\d{1,3}\b', "IP Address"),
            (r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', "Email"),
            (r'[a-z2-7]{16,56}\.onion', "Onion Address"),
            (r'\\\\[a-zA-Z0-9._-]+\\[a-zA-Z0-9$._-]+', "UNC Path"),
            (r'HKEY_[A-Z_]+\\[^\s]+', "Registry Key"),
            (r'cmd\.exe|powershell\.exe|wscript\.exe|cscript\.exe', "Script Interpreter"),
            (r'password|passwd|pwd|credential|secret|key|token', "Credential Keyword"),
            (r'bitcoin|btc|wallet|ransom|decrypt|encrypt', "Ransomware Keyword"),
            (r'bot|c2|cnc|command|control|beacon', "C2 Keyword")
        ]
        
        self.packer_signatures = {
            "UPX": [b"UPX0", b"UPX1", b"UPX!"],
            "ASPACK": [b"ASPack", b".aspack"],
            "PETITE": [b"petite", b".petite"],
            "MPRESS": [b"MPRESS1", b"MPRESS2"],
            "THEMIDA": [b"Themida", b".themida"],
            "VMPROTECT": [b"VMProtect", b".vmp0", b".vmp1"]
        }
    
    def calculate_hashes(self, data: bytes) -> FileHashes:
        """Calculate file hashes"""
        return FileHashes(
            md5=hashlib.md5(data).hexdigest(),
            sha1=hashlib.sha1(data).hexdigest(),
            sha256=hashlib.sha256(data).hexdigest(),
            sha512=hashlib.sha512(data).hexdigest(),
            ssdeep=None,  # Requires ssdeep library
            imphash=None,  # Calculated from imports
            tlsh=None  # Requires tlsh library
        )
    
    def calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy"""
        if not data:
            return 0.0
        
        byte_counts = [0] * 256
        for byte in data:
            byte_counts[byte] += 1
        
        entropy = 0.0
        length = len(data)
        for count in byte_counts:
            if count > 0:
                probability = count / length
                entropy -= probability * math.log2(probability)
        
        return round(entropy, 4)
    
    def extract_strings(self, data: bytes, min_length: int = 4) -> List[str]:
        """Extract ASCII and Unicode strings"""
        strings = []
        
        # ASCII strings
        ascii_pattern = re.compile(rb'[\x20-\x7e]{%d,}' % min_length)
        for match in ascii_pattern.finditer(data):
            try:
                strings.append(match.group().decode('ascii'))
            except UnicodeDecodeError as e:
                logger.debug(f"Failed to decode ASCII string: {e}")
        
        # Unicode strings
        unicode_pattern = re.compile(rb'(?:[\x20-\x7e]\x00){%d,}' % min_length)
        for match in unicode_pattern.finditer(data):
            try:
                strings.append(match.group().decode('utf-16-le').rstrip('\x00'))
            except UnicodeDecodeError as e:
                logger.debug(f"Failed to decode Unicode string: {e}")
        
        return list(set(strings))[:1000]  # Limit to 1000 unique strings
    
    def find_suspicious_strings(self, strings: List[str]) -> List[Dict[str, str]]:
        """Find suspicious strings"""
        suspicious = []
        
        for string in strings:
            for pattern, category in self.suspicious_string_patterns:
                if re.search(pattern, string, re.IGNORECASE):
                    suspicious.append({
                        "string": string[:200],
                        "category": category,
                        "pattern": pattern
                    })
                    break
        
        return suspicious[:100]  # Limit to 100
    
    def detect_packer(self, data: bytes) -> Optional[PackerType]:
        """Detect packer/crypter"""
        for packer_name, signatures in self.packer_signatures.items():
            for sig in signatures:
                if sig in data:
                    return PackerType[packer_name]
        return PackerType.NONE
    
    def parse_pe_header(self, data: bytes) -> Optional[PEHeader]:
        """Parse PE header"""
        try:
            # Check MZ signature
            if data[:2] != b'MZ':
                return None
            
            # Get PE header offset
            pe_offset = struct.unpack('<I', data[0x3C:0x40])[0]
            
            # Check PE signature
            if data[pe_offset:pe_offset+4] != b'PE\x00\x00':
                return None
            
            # Parse COFF header
            coff_offset = pe_offset + 4
            machine = struct.unpack('<H', data[coff_offset:coff_offset+2])[0]
            timestamp = struct.unpack('<I', data[coff_offset+4:coff_offset+8])[0]
            characteristics = struct.unpack('<H', data[coff_offset+18:coff_offset+20])[0]
            
            # Machine type mapping
            machine_types = {
                0x14c: "i386",
                0x8664: "AMD64",
                0x1c0: "ARM",
                0xaa64: "ARM64"
            }
            
            # Parse optional header
            opt_offset = coff_offset + 20
            magic = struct.unpack('<H', data[opt_offset:opt_offset+2])[0]
            
            if magic == 0x10b:  # PE32
                entry_point = struct.unpack('<I', data[opt_offset+16:opt_offset+20])[0]
                image_base = struct.unpack('<I', data[opt_offset+28:opt_offset+32])[0]
            elif magic == 0x20b:  # PE32+
                entry_point = struct.unpack('<I', data[opt_offset+16:opt_offset+20])[0]
                image_base = struct.unpack('<Q', data[opt_offset+24:opt_offset+32])[0]
            else:
                return None
            
            # Characteristics flags
            char_flags = []
            if characteristics & 0x0002:
                char_flags.append("EXECUTABLE_IMAGE")
            if characteristics & 0x0020:
                char_flags.append("LARGE_ADDRESS_AWARE")
            if characteristics & 0x2000:
                char_flags.append("DLL")
            
            return PEHeader(
                machine=machine_types.get(machine, f"0x{machine:04x}"),
                timestamp=datetime.utcfromtimestamp(timestamp).isoformat(),
                characteristics=char_flags,
                subsystem="WINDOWS_GUI",
                dll_characteristics=[],
                entry_point=entry_point,
                image_base=image_base,
                section_alignment=0x1000,
                file_alignment=0x200,
                size_of_image=0,
                size_of_headers=0,
                checksum=0
            )
        except Exception as e:
            return None
    
    def analyze(self, data: bytes, filename: str) -> StaticAnalysisResult:
        """Perform static analysis"""
        # Calculate hashes
        hashes = self.calculate_hashes(data)
        
        # Determine file type
        file_type = self._detect_file_type(data)
        
        # Calculate entropy
        entropy = self.calculate_entropy(data)
        
        # Extract strings
        strings = self.extract_strings(data)
        suspicious_strings = self.find_suspicious_strings(strings)
        
        # Detect packer
        packer = self.detect_packer(data)
        
        # Parse PE if applicable
        pe_header = None
        sections = []
        imports = []
        exports = []
        
        if file_type in [FileType.PE_EXE, FileType.PE_DLL, FileType.PE_SYS]:
            pe_header = self.parse_pe_header(data)
        
        # Detect obfuscation
        obfuscation = self._detect_obfuscation(data, strings, entropy)
        
        return StaticAnalysisResult(
            file_type=file_type,
            file_size=len(data),
            hashes=hashes,
            pe_header=pe_header,
            sections=sections,
            imports=imports,
            exports=exports,
            strings=strings[:100],  # Limit strings in result
            suspicious_strings=suspicious_strings,
            entropy=entropy,
            packer=packer,
            obfuscation=obfuscation,
            resources=[],
            certificates=[],
            version_info={}
        )
    
    def _detect_file_type(self, data: bytes) -> FileType:
        """Detect file type from magic bytes"""
        if data[:2] == b'MZ':
            # Check if DLL or EXE
            try:
                pe_offset = struct.unpack('<I', data[0x3C:0x40])[0]
                characteristics = struct.unpack('<H', data[pe_offset+22:pe_offset+24])[0]
                if characteristics & 0x2000:
                    return FileType.PE_DLL
                return FileType.PE_EXE
            except:
                return FileType.PE_EXE
        elif data[:4] == b'\x7fELF':
            return FileType.ELF
        elif data[:4] in [b'\xfe\xed\xfa\xce', b'\xfe\xed\xfa\xcf', b'\xca\xfe\xba\xbe']:
            return FileType.MACHO
        elif data[:4] == b'PK\x03\x04':
            if b'AndroidManifest.xml' in data:
                return FileType.APK
            return FileType.ARCHIVE
        elif data[:5] == b'%PDF-':
            return FileType.PDF
        elif data[:8] == b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1':
            return FileType.OFFICE
        elif data[:2] in [b'#!', b'<?' , b'<!']:
            return FileType.SCRIPT
        return FileType.UNKNOWN
    
    def _detect_obfuscation(self, data: bytes, strings: List[str], entropy: float) -> List[ObfuscationType]:
        """Detect obfuscation techniques"""
        obfuscation = []
        
        # High entropy suggests encryption/packing
        if entropy > 7.5:
            obfuscation.append(ObfuscationType.STRING_ENCRYPTION)
        
        # Check for API hashing patterns
        api_hash_patterns = [
            rb'\x68[\x00-\xff]{4}\xe8',  # push hash; call
            rb'ror\s+e[a-d]x',  # ROR instruction
        ]
        for pattern in api_hash_patterns:
            if re.search(pattern, data):
                obfuscation.append(ObfuscationType.API_HASHING)
                break
        
        # Check for control flow obfuscation
        jmp_count = data.count(b'\xeb') + data.count(b'\xe9')
        if jmp_count > len(data) / 50:
            obfuscation.append(ObfuscationType.CONTROL_FLOW)
        
        return obfuscation


class DynamicAnalyzer:
    """Dynamic malware analysis engine"""
    
    def __init__(self):
        self.sandbox_available = False
        self.analysis_timeout = 300  # 5 minutes
    
    def analyze(self, file_path: str, sandbox: SandboxType = SandboxType.WINDOWS_10,
                timeout: int = 300) -> DynamicAnalysisResult:
        """Perform dynamic analysis in sandbox"""
        # This would integrate with actual sandbox (Cuckoo, CAPE, etc.)
        # For now, return structured result indicating sandbox requirement
        
        return DynamicAnalysisResult(
            sandbox=sandbox,
            duration=timeout,
            processes_created=[],
            files_created=[],
            files_modified=[],
            files_deleted=[],
            registry_created=[],
            registry_modified=[],
            registry_deleted=[],
            network_connections=[],
            dns_queries=[],
            http_requests=[],
            mutexes_created=[],
            api_calls=[],
            screenshots=[],
            memory_dumps=[],
            dropped_files=[]
        )


class BehavioralAnalyzer:
    """Behavioral analysis engine"""
    
    def __init__(self):
        self.behavior_rules = self._initialize_rules()
    
    def _initialize_rules(self) -> List[Dict[str, Any]]:
        """Initialize behavioral detection rules"""
        return [
            {
                "name": "process_injection",
                "category": "Defense Evasion",
                "description": "Process injection detected",
                "indicators": ["WriteProcessMemory", "CreateRemoteThread", "NtUnmapViewOfSection"],
                "mitre": "T1055",
                "severity": ThreatLevel.HIGH
            },
            {
                "name": "credential_theft",
                "category": "Credential Access",
                "description": "Credential theft behavior detected",
                "indicators": ["lsass.exe", "SAM", "SECURITY", "mimikatz"],
                "mitre": "T1003",
                "severity": ThreatLevel.CRITICAL
            },
            {
                "name": "persistence_registry",
                "category": "Persistence",
                "description": "Registry persistence mechanism detected",
                "indicators": ["Run", "RunOnce", "CurrentVersion\\Run"],
                "mitre": "T1547.001",
                "severity": ThreatLevel.HIGH
            },
            {
                "name": "persistence_scheduled_task",
                "category": "Persistence",
                "description": "Scheduled task persistence detected",
                "indicators": ["schtasks", "/create", "at.exe"],
                "mitre": "T1053",
                "severity": ThreatLevel.HIGH
            },
            {
                "name": "data_exfiltration",
                "category": "Exfiltration",
                "description": "Data exfiltration behavior detected",
                "indicators": ["ftp://", "sftp://", "POST", "upload"],
                "mitre": "T1041",
                "severity": ThreatLevel.CRITICAL
            },
            {
                "name": "ransomware_behavior",
                "category": "Impact",
                "description": "Ransomware behavior detected",
                "indicators": ["CryptEncrypt", ".encrypted", "ransom", "bitcoin"],
                "mitre": "T1486",
                "severity": ThreatLevel.CRITICAL
            },
            {
                "name": "keylogger",
                "category": "Collection",
                "description": "Keylogger behavior detected",
                "indicators": ["GetAsyncKeyState", "SetWindowsHookEx", "GetKeyState"],
                "mitre": "T1056.001",
                "severity": ThreatLevel.HIGH
            },
            {
                "name": "anti_analysis",
                "category": "Defense Evasion",
                "description": "Anti-analysis technique detected",
                "indicators": ["IsDebuggerPresent", "CheckRemoteDebuggerPresent", "vmware", "virtualbox"],
                "mitre": "T1497",
                "severity": ThreatLevel.MEDIUM
            }
        ]
    
    def analyze(self, static_result: StaticAnalysisResult,
                dynamic_result: Optional[DynamicAnalysisResult] = None) -> List[BehavioralIndicator]:
        """Analyze behavior based on static and dynamic results"""
        indicators = []
        
        # Combine all strings for analysis
        all_strings = static_result.strings + [s["string"] for s in static_result.suspicious_strings]
        all_strings_lower = [s.lower() for s in all_strings]
        
        for rule in self.behavior_rules:
            matched_indicators = []
            for indicator in rule["indicators"]:
                if any(indicator.lower() in s for s in all_strings_lower):
                    matched_indicators.append(indicator)
            
            if len(matched_indicators) >= 1:
                indicators.append(BehavioralIndicator(
                    category=rule["category"],
                    description=rule["description"],
                    severity=rule["severity"],
                    mitre_technique=rule["mitre"],
                    evidence=matched_indicators
                ))
        
        return indicators


class MalwareFamilyClassifier:
    """Malware family classification engine"""
    
    def __init__(self):
        self.family_signatures = {
            "Emotet": {
                "strings": ["emotet", "epoch"],
                "behaviors": ["process_injection", "persistence_registry"],
                "type": MalwareType.TROJAN
            },
            "TrickBot": {
                "strings": ["trickbot", "trick", "moduleconfig"],
                "behaviors": ["credential_theft", "persistence_scheduled_task"],
                "type": MalwareType.BANKER
            },
            "Ryuk": {
                "strings": ["ryuk", "hermes", "RyukReadMe"],
                "behaviors": ["ransomware_behavior"],
                "type": MalwareType.RANSOMWARE
            },
            "Cobalt Strike": {
                "strings": ["cobaltstrike", "beacon", "sleeptime"],
                "behaviors": ["process_injection"],
                "type": MalwareType.APT_IMPLANT
            },
            "Mimikatz": {
                "strings": ["mimikatz", "sekurlsa", "kerberos::"],
                "behaviors": ["credential_theft"],
                "type": MalwareType.INFOSTEALER
            },
            "LockBit": {
                "strings": ["lockbit", "restore-my-files"],
                "behaviors": ["ransomware_behavior"],
                "type": MalwareType.RANSOMWARE
            },
            "Agent Tesla": {
                "strings": ["agenttesla", "smtp", "keylog"],
                "behaviors": ["keylogger", "data_exfiltration"],
                "type": MalwareType.INFOSTEALER
            }
        }
    
    def classify(self, static_result: StaticAnalysisResult,
                 behavioral_indicators: List[BehavioralIndicator]) -> Tuple[Optional[str], Optional[MalwareType]]:
        """Classify malware family"""
        all_strings = [s.lower() for s in static_result.strings]
        all_strings.extend([s["string"].lower() for s in static_result.suspicious_strings])
        
        behavior_names = [b.category.lower().replace(" ", "_") for b in behavioral_indicators]
        
        best_match = None
        best_score = 0
        
        for family_name, signature in self.family_signatures.items():
            score = 0
            
            # Check strings
            for sig_string in signature["strings"]:
                if any(sig_string.lower() in s for s in all_strings):
                    score += 2
            
            # Check behaviors
            for behavior in signature["behaviors"]:
                if behavior in behavior_names:
                    score += 1
            
            if score > best_score:
                best_score = score
                best_match = (family_name, signature["type"])
        
        if best_score >= 2:
            return best_match
        
        return None, None


class MalwareAnalysisEngine:
    """Main malware analysis engine"""
    
    def __init__(self):
        self.static_analyzer = StaticAnalyzer()
        self.dynamic_analyzer = DynamicAnalyzer()
        self.behavioral_analyzer = BehavioralAnalyzer()
        self.family_classifier = MalwareFamilyClassifier()
        self.reports: Dict[str, MalwareAnalysisReport] = {}
    
    def analyze_file(self, file_path: str, run_dynamic: bool = False) -> MalwareAnalysisReport:
        """Perform complete malware analysis"""
        # Read file
        with open(file_path, 'rb') as f:
            data = f.read()
        
        filename = os.path.basename(file_path)
        
        # Static analysis
        static_result = self.static_analyzer.analyze(data, filename)
        
        # Dynamic analysis (if requested and available)
        dynamic_result = None
        if run_dynamic:
            dynamic_result = self.dynamic_analyzer.analyze(file_path)
        
        # Behavioral analysis
        behavioral_indicators = self.behavioral_analyzer.analyze(static_result, dynamic_result)
        
        # Family classification
        family_name, malware_type = self.family_classifier.classify(static_result, behavioral_indicators)
        
        # Determine threat level
        threat_level = self._calculate_threat_level(static_result, behavioral_indicators)
        
        # Extract IOCs
        iocs = self._extract_iocs(static_result)
        
        # Detect evasion techniques
        evasion = self._detect_evasion(static_result, behavioral_indicators)
        
        # Map to MITRE techniques
        mitre_techniques = list(set([b.mitre_technique for b in behavioral_indicators if b.mitre_technique]))
        
        # Generate recommendations
        recommendations = self._generate_recommendations(threat_level, behavioral_indicators)
        
        # Create report
        report = MalwareAnalysisReport(
            analysis_id=f"MAL-{secrets.token_hex(8).upper()}",
            file_name=filename,
            file_type=static_result.file_type,
            threat_level=threat_level,
            malware_type=malware_type,
            malware_family=family_name,
            static_analysis=static_result,
            dynamic_analysis=dynamic_result,
            behavioral_indicators=behavioral_indicators,
            yara_matches=[],
            iocs=iocs,
            evasion_techniques=evasion,
            mitre_techniques=mitre_techniques,
            recommendations=recommendations,
            timestamp=datetime.utcnow().isoformat()
        )
        
        self.reports[report.analysis_id] = report
        return report
    
    def analyze_bytes(self, data: bytes, filename: str = "sample.bin") -> MalwareAnalysisReport:
        """Analyze malware from bytes"""
        # Static analysis
        static_result = self.static_analyzer.analyze(data, filename)
        
        # Behavioral analysis
        behavioral_indicators = self.behavioral_analyzer.analyze(static_result, None)
        
        # Family classification
        family_name, malware_type = self.family_classifier.classify(static_result, behavioral_indicators)
        
        # Determine threat level
        threat_level = self._calculate_threat_level(static_result, behavioral_indicators)
        
        # Extract IOCs
        iocs = self._extract_iocs(static_result)
        
        # Detect evasion techniques
        evasion = self._detect_evasion(static_result, behavioral_indicators)
        
        # Map to MITRE techniques
        mitre_techniques = list(set([b.mitre_technique for b in behavioral_indicators if b.mitre_technique]))
        
        # Generate recommendations
        recommendations = self._generate_recommendations(threat_level, behavioral_indicators)
        
        # Create report
        report = MalwareAnalysisReport(
            analysis_id=f"MAL-{secrets.token_hex(8).upper()}",
            file_name=filename,
            file_type=static_result.file_type,
            threat_level=threat_level,
            malware_type=malware_type,
            malware_family=family_name,
            static_analysis=static_result,
            dynamic_analysis=None,
            behavioral_indicators=behavioral_indicators,
            yara_matches=[],
            iocs=iocs,
            evasion_techniques=evasion,
            mitre_techniques=mitre_techniques,
            recommendations=recommendations,
            timestamp=datetime.utcnow().isoformat()
        )
        
        self.reports[report.analysis_id] = report
        return report
    
    def _calculate_threat_level(self, static_result: StaticAnalysisResult,
                                behavioral_indicators: List[BehavioralIndicator]) -> ThreatLevel:
        """Calculate overall threat level"""
        score = 0
        
        # High entropy
        if static_result.entropy > 7.5:
            score += 20
        elif static_result.entropy > 7.0:
            score += 10
        
        # Packer detected
        if static_result.packer and static_result.packer != PackerType.NONE:
            score += 15
        
        # Suspicious strings
        score += min(len(static_result.suspicious_strings) * 2, 30)
        
        # Behavioral indicators
        for indicator in behavioral_indicators:
            if indicator.severity == ThreatLevel.CRITICAL:
                score += 30
            elif indicator.severity == ThreatLevel.HIGH:
                score += 20
            elif indicator.severity == ThreatLevel.MEDIUM:
                score += 10
        
        # Obfuscation
        score += len(static_result.obfuscation) * 10
        
        if score >= 80:
            return ThreatLevel.CRITICAL
        elif score >= 60:
            return ThreatLevel.HIGH
        elif score >= 40:
            return ThreatLevel.MEDIUM
        elif score >= 20:
            return ThreatLevel.LOW
        return ThreatLevel.CLEAN
    
    def _extract_iocs(self, static_result: StaticAnalysisResult) -> List[Dict[str, str]]:
        """Extract IOCs from analysis"""
        iocs = []
        
        # Add hashes
        iocs.append({"type": "md5", "value": static_result.hashes.md5})
        iocs.append({"type": "sha1", "value": static_result.hashes.sha1})
        iocs.append({"type": "sha256", "value": static_result.hashes.sha256})
        
        # Extract from suspicious strings
        for sus in static_result.suspicious_strings:
            if sus["category"] == "IP Address":
                iocs.append({"type": "ip", "value": sus["string"]})
            elif sus["category"] == "URL":
                iocs.append({"type": "url", "value": sus["string"]})
            elif sus["category"] == "Email":
                iocs.append({"type": "email", "value": sus["string"]})
            elif sus["category"] == "Onion Address":
                iocs.append({"type": "onion", "value": sus["string"]})
        
        return iocs
    
    def _detect_evasion(self, static_result: StaticAnalysisResult,
                       behavioral_indicators: List[BehavioralIndicator]) -> List[EvasionTechnique]:
        """Detect evasion techniques"""
        evasion = []
        
        all_strings = [s.lower() for s in static_result.strings]
        
        # Anti-VM
        vm_indicators = ["vmware", "virtualbox", "vbox", "qemu", "xen", "hyperv"]
        if any(ind in s for s in all_strings for ind in vm_indicators):
            evasion.append(EvasionTechnique.ANTI_VM)
        
        # Anti-Debug
        debug_indicators = ["isdebuggerpresent", "checkremotedebugger", "ntqueryinformationprocess"]
        if any(ind in s for s in all_strings for ind in debug_indicators):
            evasion.append(EvasionTechnique.ANTI_DEBUG)
        
        # Anti-Sandbox
        sandbox_indicators = ["sandbox", "cuckoo", "joe", "any.run", "hybrid-analysis"]
        if any(ind in s for s in all_strings for ind in sandbox_indicators):
            evasion.append(EvasionTechnique.ANTI_SANDBOX)
        
        # Timing-based
        timing_indicators = ["sleep", "gettickcount", "queryperformancecounter"]
        if any(ind in s for s in all_strings for ind in timing_indicators):
            evasion.append(EvasionTechnique.TIMING_BASED)
        
        return evasion
    
    def _generate_recommendations(self, threat_level: ThreatLevel,
                                  behavioral_indicators: List[BehavioralIndicator]) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        if threat_level in [ThreatLevel.CRITICAL, ThreatLevel.HIGH]:
            recommendations.append("Immediately isolate affected systems from the network")
            recommendations.append("Preserve evidence for forensic analysis")
            recommendations.append("Block identified IOCs at network perimeter")
            recommendations.append("Scan all systems for similar indicators")
        
        for indicator in behavioral_indicators:
            if indicator.category == "Credential Access":
                recommendations.append("Reset all potentially compromised credentials")
                recommendations.append("Enable multi-factor authentication")
            elif indicator.category == "Persistence":
                recommendations.append("Check and clean persistence mechanisms")
                recommendations.append("Review scheduled tasks and services")
            elif indicator.category == "Exfiltration":
                recommendations.append("Review network logs for data exfiltration")
                recommendations.append("Assess scope of potential data breach")
        
        return list(set(recommendations))


# Factory function for API use
def create_malware_engine() -> MalwareAnalysisEngine:
    """Create malware analysis engine instance"""
    return MalwareAnalysisEngine()
